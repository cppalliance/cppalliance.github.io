<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Richard's November/December Update | The C++ Alliance</title>
<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
<!-- Bootstrap core CSS -->
<link href="/css/style.css" rel="stylesheet">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=1">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=1">
<link rel="manifest" href="/site.webmanifest?v=1">
<link rel="mask-icon" href="/safari-pinned-tab.svg?v=1" color="#a91c20">
<link rel="shortcut icon" href="/favicon.ico?v=1">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Richard’s November/December Update | The C++ Alliance</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Richard’s November/December Update" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A Coroutine Websocket Using Boost Beast This month I thought I would present a little idea that I had a few months ago. Boost.Beast is a very comprehensive and competent websocket implementation, but it is not what you might call “straightforward” to use unless you are already wise in the ways of Asio. Beast’s documentation and design makes no apology for this. There is a disclaimer in the documentation: To use Beast effectively, a prior understanding of Networking is required. This is worth taking seriously (and if you are not fully aware of how Asio works with respect to the posting of completion handlers onto the associated executor, this page is worth studying). The Interface I wanted to model my websocket object’s interface roughly on the javascript websocket connection interface. There will be a few differences of course, because the javascript version uses callbacks (or continuations) and I will be using C++ coroutines that execute on an Asio executor. In underlying implementation, these concepts are not actually that far apart, since Asio awaitables are actually implemented in terms of the normal asio completion token/handler interaction. Furthermore, I want my WebSocket’s connection phase to be cancellable. My websocket interface will look something like this: namespace websocket { struct message { bool is_binary() const; bool is_text() const; std::string_view operator*() const; }; struct event { bool is_error() const; bool is_message() const; error_code const&amp; error() const; message const&amp; message() const; }; struct connection { /// Schedule a frame to be sent at some point in the near future void send(std::string_view data, bool as_text = true); /// Suspend and wait until either there is a message available or an error net::awaitable&lt;event&gt; consume(); /// Close the websocket and suspend until it is closed. net::awaitable&lt;void&gt; close(beast::websocket::close_reason = /* a sensible default */); /// Send the close frame to the server but don&#39;t hang around to wait /// for the confirmation. void drop(beast::websocket::close_reason = /* a sensible default */); /// If consume() exits with an error of beast::websocket::error::closed then this /// will return the reason for the closure as sent by the server. /// Otherwise undefined. beast::websocket::close_reason reason() const; }; net::awaitable&lt;connection&gt; connect(std::string url, connect_options options /* = some default */); } The idea here is to keep the interface as lightweight and as simple as possible. The websocket connection will run on the executor of the coroutine that created it. Any commands sent to the websocket will be executor safe. That is, internally their work will be dispatched to the websocket connection’s executor. The exception to this will be the close_reason method, which must only be called once the connection’s consume coroutine has returned an error event. It is a guarantee that once consume returns an event that is an error, it will never return anything else, and no other method on the connection will mutate its internal state. In this condition, it is legal to call the reason method. A typical use would look like this: // default options auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); for(;;) { auto event = co_await ws.consume(); if (event.is_error()) break; else on_message(std::move(event.message())); } The above code example does not provide any means to write to the websocket. But it would be trivial to either spawn another coroutine to handle the writer, or call a function in order to signal some orthogonal process that the websocket was ready. // default options auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); on_connected(ws); // The websocket object should be shared-copyable for(;;) { auto event = co_await ws.consume(); if (event.is_error()) { on_close(); break; } else on_message(std::move(event.message())); } Another way to visualise a websocket is exactly as javascript’s websocket connection does, using callbacks or continuations in order to notify user code that the websocket has received data or closed. It would be trivial to wrap our coroutine version in order to provide this functionality. We would need to spawn a coroutine in order to run the consume() loop and then somehow signal it to stop if the websocket was disposed of. User code might then start to look something like this: websocket::connect(&quot;wss://echo.websocket.org&quot;, options) .on_connect([](websocket::connection ws) { run_my_loop(ws); }); void run_my_loop(websocket::connection ws) { bool closed = false; ws.on_close([&amp;]{ closed = true; }); ws.on_error([&amp;]{ closed = true; }); ws.on_message([&amp;](websocket::message msg){ process_message(msg); }); // some time later ws.send(&quot;Hello, World!&quot;); } With this style of interface we would need some means of passing the executor on which the continuations would be invoked. A reasonable place to do this might be the options parameter. In the JavaScript style interface, it would be important to be able to detect when the websocket has gone out of scope and ensure that it closes correctly, otherwise we’ll have a rogue resource out there with no handle by which we can close it. This argues that the actual websocket::connection class should be a handle to an internal implementation and that the destructor of the handle should ensure that the implementation is signalled so that it can drop the connection and shutdown cleanly. Under the covers, we’re implementing this websocket in Boost.Beast. As with all Asio objects, there could be (probably will be) asynchronous operations in progress at the time the websocket handle goes out of scope. Thinking this through, it means that: The implementation is going to live longer than the lifetime of the last copy of the handle owning the implementation. There needs to be some mechanism to cancel the underlying implementation’s operations. Coroutines can be visualised as threads of execution. In the world of threads (e.g. std::thread) we have primitives such as std::stop_token and std::condition_variable. The C++ Standard Library does not yet have these primitives for coroutines. And if it did it would be questionable whether they would be suitable for networking code where coroutines are actually built on top of Asio composed operations. Does Asio itself provide anything we can use? Asio’s Hidden Asynchronous condition_variable The answer is surprisingly, yes. But not in the form I was expecting when I asked Chris Kohlhoff (Asio’s author and maintainer) about it. It turns out that asio’s timer models an asynchronous version of a condition variable perfectly. Consider: Given: auto t = net::steady_timer(co_await net::this_coro::executor); t.expires_at(std::chrono::stready_clock::time_point::max()); Then we can write: template&lt;class Pred&gt; net::awaitable&lt;void&gt; wait(net::steady_timer&amp; t, Pred predicate) { error_code ec; while(!ec &amp;&amp; !predicate()) { co_await t.async_wait(net::redirect_error(net::use_awaitable, ec)); if (ec == net::error::operation_aborted) // timer cancelled continue; else throw std::logic_error(&quot;unexpected error&quot;); } } void notify(net::steady_timer&amp; t) { // assuming we are executing on the same executor as the wait() t.cancel(); } Which gives us a simple asynchronous condition_variable (this one does not implement timeouts, but it would be trivial to extend this code to accommodate them). Asynchronous Stop Token The std::stop_token is a welcome addition to the standard, but it is a little heavyweight for asynchronous code that runs in an executor, which is already thread-safe by design. A simple in-executor stop source can be implemented something like this: namespace async { namespace detail { struct shared_state { void stop() { if (!std::exchange(stopped_, true)) { auto sigs = std::move(signals_); signals_.clear(); for(auto&amp; s : sigs) s(); } } std::list&lt;std::function&lt;void()&gt;&gt; signals_; bool stopped_ = false; }; } struct stop_source { void stop() { impl_-&gt;stop(); } std::shared_ptr&lt;shared_state&gt; impl_; } struct stop_connection { }; struct stop_token { stop_token(stop_source&amp; source) : impl_(source.impl_) { } bool stopped() const { return !impl_ || impl_-&gt;stopped_; } stop_connection connect(std::function&lt;void()&gt; slot); std::shared_ptr&lt;shared_state&gt; impl_; } } The use case would look something like this: net::awaitable&lt;void&gt; something_with_websocket(async::stop_token token) { // passing the stop token allows the connect call to abort early // if the owner of the stop_source wants to end the use of the // websocket before it is connected auto ws = websocket::connect(&quot;wss://echo.websocket.org&quot;, websocket::connect_options { .stop_token = token }); // connect a slot to the stop token which drops the connection auto stopconn = token.connect([&amp;] { ws.drop(); }; for(;;} { auto event = co_await ws.consume(); // ...etc } } Now, armed with both a stop_token and a condition_variable, we gain a great deal of flexibility with programs running on an Asio-style executor. So let’s build a little chat app to talk the the echo bot. Coding style when using Asio coroutines. I mentioned earlier that I like to decompose objects with complex lifetimes into an impl and handle. My personal programming style for naming the components is as follows: The implementation This is the class that implements the complex functionality that we want. I generally give this class an _impl suffix and apply the following guidelines: The impl does not control its own lifetime. Calls to the impl are expected to already be executing on the correct thread or strand, and in the case of multi-threaded code, are expected to have already taken a lock on any mutex. This is a personal preference which I find tends to lower the complexity of the object, since the interface functions do not have to manage more than one concern, and deadlocks etc are not possible. The lifetime When holding an object in shared_ptr, we get a chance to intercept the destruction of the last handle. At this point we do not have to destroy the implementation, but can allow it to shut down gracefully before destruction. In order to do this, particularly with an object that is referenced by internal coroutines, I have found that it’s useful to separate the public lifetime of the object, and its internal lifetime, which may be longer than the public one. A convenient, if not especially efficient way to do this is to hold two shared_ptr’s in the handle. One being a shared_ptr which has a custom destructor - the lifetime ptr, and one being a normal shared_ptr to the implementation which can be copied in order to extend its private lifetime while it shuts down. It is the responsibility of the custom deleter to signal the implementation that it should start shutting down. In this case, the websocket connection’s public handle may look something like this: namespace websocket { struct connection_lifetime { connection_lifetime(std::shared_ptr&lt;connection_impl&gt;&amp;&amp; adopted) : impl_(std::move(adopted)) , lifetime_(new_lifetime(impl_)) { } static std::shared_ptr&lt;void&gt; new_lifetime(std::shared_ptr&lt;connection_impl&gt; const&amp; impl) { static int useful_address; auto deleter = [impl](int*) noexcept { net::co_spawn(impl-&gt;get_executor(), [impl]() -&gt; net::awaitable&lt;void&gt; { co_await impl-&gt;stop(); }, net::detached); }; return std::shared_ptr&lt;void&gt;(&amp;useful_address, deleter); } std::shared_ptr&lt;connection_impl&gt; impl_; std::shared_ptr&lt;void&gt; lifetime_; }; struct connection { connection(connection_lifetime l); }; } The interesting part here is in the function new_lifetime. There are a few things going on here. First, we are capturing the internal lifetime of our connection_impl and storing it in the deleter of the lifetime pointer. This of course means that the private implementation will live at least as long as the public lifetime. Secondly, the deleter does not actually delete anything. It merely captures a copy of the impl pointer and runs a coroutine on the impl to completion before releasing the impl pointer. The idea is that this coroutine will not complete until all internal coroutines within the implementation have completed. The provides the fortunate side effect that operations running inside the impl do not have to capture the impl’s lifetime via shared_from_this. It turns out that this aids composability, since subordinate coroutines within the implementation can be written as free functions, and ported to other implementations that may not involve a shared_ptr. It also means that the impl itself can be composed, since it has no restrictions on lifetime semantics. i.e. If I wanted to implement a JSON-RPC connection by deriving from the websocket::connection_impl, I do not have to be concerned about translating shared_ptrs internally in the derived class. Once it’s all put together Finally, having created all the primitives (which I really should start collating into a library), we can test our little websocket chat client, which becomes a very simple program: Here’s main: int main() { net::io_context ioctx; net::co_spawn( ioctx.get_executor(), [] { return chat(); }, net::detached); ioctx.run(); } And here’s the chat() coroutine: net::awaitable&lt; void &gt; chat() { // connect the websocket auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); // spawn the coroutine to read console input and send it to the websocket auto stop_children = async::stop_source(); net::co_spawn( co_await net::this_coro::executor, [stop = async::stop_token(stop_children), ws]() mutable { return do_console(std::move(stop), std::move(ws)); }, net::detached); // read events from the websocket connection. for (;;) { auto event = co_await ws.consume(); if (event.is_error()) { if (event.error() == beast::websocket::error::closed) std::cerr &lt;&lt; &quot;peer closed connection: &quot; &lt;&lt; ws.reason() &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;connection error: &quot; &lt;&lt; event.error() &lt;&lt; std::endl; break; } else { std::cout &lt;&lt; &quot;message received: &quot; &lt;&lt; event.message() &lt;&lt; std::endl; } } // at this point, the stop_source goes out of scope, // which will cause the console coroutine to exit. } And finally, the do_console() coroutine. Note that I have used asio’s posix interface to collect console input. In order to run compile in a WIN32 environment, we’d need to do something different (suggestions welcome via PR!). net::awaitable&lt; void &gt; do_console(async::stop_token stop, websocket::connection ws) try { auto console = asio::posix::stream_descriptor( co_await net::this_coro::executor, ::dup(STDIN_FILENO)); auto stopconn = stop.connect([&amp;] { console.cancel(); }); std::string console_chars; while (!stop.stopped()) { auto line_len = co_await net::async_read_until(console, net::dynamic_buffer(console_chars), &#39;\n&#39;, net::use_awaitable); auto line = console_chars.substr(0, line_len - 1); console_chars.erase(0, line_len); std::cout &lt;&lt; &quot;you typed this: &quot; &lt;&lt; line &lt;&lt; std::endl; ws.send(line); } } catch(...) { // error handling here } If you’d like to look into the complete code, submit a PR or offer some (probably well-deserved) criticism, you will find the code repository here." />
<meta property="og:description" content="A Coroutine Websocket Using Boost Beast This month I thought I would present a little idea that I had a few months ago. Boost.Beast is a very comprehensive and competent websocket implementation, but it is not what you might call “straightforward” to use unless you are already wise in the ways of Asio. Beast’s documentation and design makes no apology for this. There is a disclaimer in the documentation: To use Beast effectively, a prior understanding of Networking is required. This is worth taking seriously (and if you are not fully aware of how Asio works with respect to the posting of completion handlers onto the associated executor, this page is worth studying). The Interface I wanted to model my websocket object’s interface roughly on the javascript websocket connection interface. There will be a few differences of course, because the javascript version uses callbacks (or continuations) and I will be using C++ coroutines that execute on an Asio executor. In underlying implementation, these concepts are not actually that far apart, since Asio awaitables are actually implemented in terms of the normal asio completion token/handler interaction. Furthermore, I want my WebSocket’s connection phase to be cancellable. My websocket interface will look something like this: namespace websocket { struct message { bool is_binary() const; bool is_text() const; std::string_view operator*() const; }; struct event { bool is_error() const; bool is_message() const; error_code const&amp; error() const; message const&amp; message() const; }; struct connection { /// Schedule a frame to be sent at some point in the near future void send(std::string_view data, bool as_text = true); /// Suspend and wait until either there is a message available or an error net::awaitable&lt;event&gt; consume(); /// Close the websocket and suspend until it is closed. net::awaitable&lt;void&gt; close(beast::websocket::close_reason = /* a sensible default */); /// Send the close frame to the server but don&#39;t hang around to wait /// for the confirmation. void drop(beast::websocket::close_reason = /* a sensible default */); /// If consume() exits with an error of beast::websocket::error::closed then this /// will return the reason for the closure as sent by the server. /// Otherwise undefined. beast::websocket::close_reason reason() const; }; net::awaitable&lt;connection&gt; connect(std::string url, connect_options options /* = some default */); } The idea here is to keep the interface as lightweight and as simple as possible. The websocket connection will run on the executor of the coroutine that created it. Any commands sent to the websocket will be executor safe. That is, internally their work will be dispatched to the websocket connection’s executor. The exception to this will be the close_reason method, which must only be called once the connection’s consume coroutine has returned an error event. It is a guarantee that once consume returns an event that is an error, it will never return anything else, and no other method on the connection will mutate its internal state. In this condition, it is legal to call the reason method. A typical use would look like this: // default options auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); for(;;) { auto event = co_await ws.consume(); if (event.is_error()) break; else on_message(std::move(event.message())); } The above code example does not provide any means to write to the websocket. But it would be trivial to either spawn another coroutine to handle the writer, or call a function in order to signal some orthogonal process that the websocket was ready. // default options auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); on_connected(ws); // The websocket object should be shared-copyable for(;;) { auto event = co_await ws.consume(); if (event.is_error()) { on_close(); break; } else on_message(std::move(event.message())); } Another way to visualise a websocket is exactly as javascript’s websocket connection does, using callbacks or continuations in order to notify user code that the websocket has received data or closed. It would be trivial to wrap our coroutine version in order to provide this functionality. We would need to spawn a coroutine in order to run the consume() loop and then somehow signal it to stop if the websocket was disposed of. User code might then start to look something like this: websocket::connect(&quot;wss://echo.websocket.org&quot;, options) .on_connect([](websocket::connection ws) { run_my_loop(ws); }); void run_my_loop(websocket::connection ws) { bool closed = false; ws.on_close([&amp;]{ closed = true; }); ws.on_error([&amp;]{ closed = true; }); ws.on_message([&amp;](websocket::message msg){ process_message(msg); }); // some time later ws.send(&quot;Hello, World!&quot;); } With this style of interface we would need some means of passing the executor on which the continuations would be invoked. A reasonable place to do this might be the options parameter. In the JavaScript style interface, it would be important to be able to detect when the websocket has gone out of scope and ensure that it closes correctly, otherwise we’ll have a rogue resource out there with no handle by which we can close it. This argues that the actual websocket::connection class should be a handle to an internal implementation and that the destructor of the handle should ensure that the implementation is signalled so that it can drop the connection and shutdown cleanly. Under the covers, we’re implementing this websocket in Boost.Beast. As with all Asio objects, there could be (probably will be) asynchronous operations in progress at the time the websocket handle goes out of scope. Thinking this through, it means that: The implementation is going to live longer than the lifetime of the last copy of the handle owning the implementation. There needs to be some mechanism to cancel the underlying implementation’s operations. Coroutines can be visualised as threads of execution. In the world of threads (e.g. std::thread) we have primitives such as std::stop_token and std::condition_variable. The C++ Standard Library does not yet have these primitives for coroutines. And if it did it would be questionable whether they would be suitable for networking code where coroutines are actually built on top of Asio composed operations. Does Asio itself provide anything we can use? Asio’s Hidden Asynchronous condition_variable The answer is surprisingly, yes. But not in the form I was expecting when I asked Chris Kohlhoff (Asio’s author and maintainer) about it. It turns out that asio’s timer models an asynchronous version of a condition variable perfectly. Consider: Given: auto t = net::steady_timer(co_await net::this_coro::executor); t.expires_at(std::chrono::stready_clock::time_point::max()); Then we can write: template&lt;class Pred&gt; net::awaitable&lt;void&gt; wait(net::steady_timer&amp; t, Pred predicate) { error_code ec; while(!ec &amp;&amp; !predicate()) { co_await t.async_wait(net::redirect_error(net::use_awaitable, ec)); if (ec == net::error::operation_aborted) // timer cancelled continue; else throw std::logic_error(&quot;unexpected error&quot;); } } void notify(net::steady_timer&amp; t) { // assuming we are executing on the same executor as the wait() t.cancel(); } Which gives us a simple asynchronous condition_variable (this one does not implement timeouts, but it would be trivial to extend this code to accommodate them). Asynchronous Stop Token The std::stop_token is a welcome addition to the standard, but it is a little heavyweight for asynchronous code that runs in an executor, which is already thread-safe by design. A simple in-executor stop source can be implemented something like this: namespace async { namespace detail { struct shared_state { void stop() { if (!std::exchange(stopped_, true)) { auto sigs = std::move(signals_); signals_.clear(); for(auto&amp; s : sigs) s(); } } std::list&lt;std::function&lt;void()&gt;&gt; signals_; bool stopped_ = false; }; } struct stop_source { void stop() { impl_-&gt;stop(); } std::shared_ptr&lt;shared_state&gt; impl_; } struct stop_connection { }; struct stop_token { stop_token(stop_source&amp; source) : impl_(source.impl_) { } bool stopped() const { return !impl_ || impl_-&gt;stopped_; } stop_connection connect(std::function&lt;void()&gt; slot); std::shared_ptr&lt;shared_state&gt; impl_; } } The use case would look something like this: net::awaitable&lt;void&gt; something_with_websocket(async::stop_token token) { // passing the stop token allows the connect call to abort early // if the owner of the stop_source wants to end the use of the // websocket before it is connected auto ws = websocket::connect(&quot;wss://echo.websocket.org&quot;, websocket::connect_options { .stop_token = token }); // connect a slot to the stop token which drops the connection auto stopconn = token.connect([&amp;] { ws.drop(); }; for(;;} { auto event = co_await ws.consume(); // ...etc } } Now, armed with both a stop_token and a condition_variable, we gain a great deal of flexibility with programs running on an Asio-style executor. So let’s build a little chat app to talk the the echo bot. Coding style when using Asio coroutines. I mentioned earlier that I like to decompose objects with complex lifetimes into an impl and handle. My personal programming style for naming the components is as follows: The implementation This is the class that implements the complex functionality that we want. I generally give this class an _impl suffix and apply the following guidelines: The impl does not control its own lifetime. Calls to the impl are expected to already be executing on the correct thread or strand, and in the case of multi-threaded code, are expected to have already taken a lock on any mutex. This is a personal preference which I find tends to lower the complexity of the object, since the interface functions do not have to manage more than one concern, and deadlocks etc are not possible. The lifetime When holding an object in shared_ptr, we get a chance to intercept the destruction of the last handle. At this point we do not have to destroy the implementation, but can allow it to shut down gracefully before destruction. In order to do this, particularly with an object that is referenced by internal coroutines, I have found that it’s useful to separate the public lifetime of the object, and its internal lifetime, which may be longer than the public one. A convenient, if not especially efficient way to do this is to hold two shared_ptr’s in the handle. One being a shared_ptr which has a custom destructor - the lifetime ptr, and one being a normal shared_ptr to the implementation which can be copied in order to extend its private lifetime while it shuts down. It is the responsibility of the custom deleter to signal the implementation that it should start shutting down. In this case, the websocket connection’s public handle may look something like this: namespace websocket { struct connection_lifetime { connection_lifetime(std::shared_ptr&lt;connection_impl&gt;&amp;&amp; adopted) : impl_(std::move(adopted)) , lifetime_(new_lifetime(impl_)) { } static std::shared_ptr&lt;void&gt; new_lifetime(std::shared_ptr&lt;connection_impl&gt; const&amp; impl) { static int useful_address; auto deleter = [impl](int*) noexcept { net::co_spawn(impl-&gt;get_executor(), [impl]() -&gt; net::awaitable&lt;void&gt; { co_await impl-&gt;stop(); }, net::detached); }; return std::shared_ptr&lt;void&gt;(&amp;useful_address, deleter); } std::shared_ptr&lt;connection_impl&gt; impl_; std::shared_ptr&lt;void&gt; lifetime_; }; struct connection { connection(connection_lifetime l); }; } The interesting part here is in the function new_lifetime. There are a few things going on here. First, we are capturing the internal lifetime of our connection_impl and storing it in the deleter of the lifetime pointer. This of course means that the private implementation will live at least as long as the public lifetime. Secondly, the deleter does not actually delete anything. It merely captures a copy of the impl pointer and runs a coroutine on the impl to completion before releasing the impl pointer. The idea is that this coroutine will not complete until all internal coroutines within the implementation have completed. The provides the fortunate side effect that operations running inside the impl do not have to capture the impl’s lifetime via shared_from_this. It turns out that this aids composability, since subordinate coroutines within the implementation can be written as free functions, and ported to other implementations that may not involve a shared_ptr. It also means that the impl itself can be composed, since it has no restrictions on lifetime semantics. i.e. If I wanted to implement a JSON-RPC connection by deriving from the websocket::connection_impl, I do not have to be concerned about translating shared_ptrs internally in the derived class. Once it’s all put together Finally, having created all the primitives (which I really should start collating into a library), we can test our little websocket chat client, which becomes a very simple program: Here’s main: int main() { net::io_context ioctx; net::co_spawn( ioctx.get_executor(), [] { return chat(); }, net::detached); ioctx.run(); } And here’s the chat() coroutine: net::awaitable&lt; void &gt; chat() { // connect the websocket auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); // spawn the coroutine to read console input and send it to the websocket auto stop_children = async::stop_source(); net::co_spawn( co_await net::this_coro::executor, [stop = async::stop_token(stop_children), ws]() mutable { return do_console(std::move(stop), std::move(ws)); }, net::detached); // read events from the websocket connection. for (;;) { auto event = co_await ws.consume(); if (event.is_error()) { if (event.error() == beast::websocket::error::closed) std::cerr &lt;&lt; &quot;peer closed connection: &quot; &lt;&lt; ws.reason() &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;connection error: &quot; &lt;&lt; event.error() &lt;&lt; std::endl; break; } else { std::cout &lt;&lt; &quot;message received: &quot; &lt;&lt; event.message() &lt;&lt; std::endl; } } // at this point, the stop_source goes out of scope, // which will cause the console coroutine to exit. } And finally, the do_console() coroutine. Note that I have used asio’s posix interface to collect console input. In order to run compile in a WIN32 environment, we’d need to do something different (suggestions welcome via PR!). net::awaitable&lt; void &gt; do_console(async::stop_token stop, websocket::connection ws) try { auto console = asio::posix::stream_descriptor( co_await net::this_coro::executor, ::dup(STDIN_FILENO)); auto stopconn = stop.connect([&amp;] { console.cancel(); }); std::string console_chars; while (!stop.stopped()) { auto line_len = co_await net::async_read_until(console, net::dynamic_buffer(console_chars), &#39;\n&#39;, net::use_awaitable); auto line = console_chars.substr(0, line_len - 1); console_chars.erase(0, line_len); std::cout &lt;&lt; &quot;you typed this: &quot; &lt;&lt; line &lt;&lt; std::endl; ws.send(line); } } catch(...) { // error handling here } If you’d like to look into the complete code, submit a PR or offer some (probably well-deserved) criticism, you will find the code repository here." />
<link rel="canonical" href="http://cppalliance.org/richard/2020/12/22/RichardsDecemberUpdate.html" />
<meta property="og:url" content="http://cppalliance.org/richard/2020/12/22/RichardsDecemberUpdate.html" />
<meta property="og:site_name" content="The C++ Alliance" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-12-22T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Richard’s November/December Update" />
<meta name="twitter:site" content="@CPPAlliance" />
<script type="application/ld+json">
{"description":"A Coroutine Websocket Using Boost Beast This month I thought I would present a little idea that I had a few months ago. Boost.Beast is a very comprehensive and competent websocket implementation, but it is not what you might call “straightforward” to use unless you are already wise in the ways of Asio. Beast’s documentation and design makes no apology for this. There is a disclaimer in the documentation: To use Beast effectively, a prior understanding of Networking is required. This is worth taking seriously (and if you are not fully aware of how Asio works with respect to the posting of completion handlers onto the associated executor, this page is worth studying). The Interface I wanted to model my websocket object’s interface roughly on the javascript websocket connection interface. There will be a few differences of course, because the javascript version uses callbacks (or continuations) and I will be using C++ coroutines that execute on an Asio executor. In underlying implementation, these concepts are not actually that far apart, since Asio awaitables are actually implemented in terms of the normal asio completion token/handler interaction. Furthermore, I want my WebSocket’s connection phase to be cancellable. My websocket interface will look something like this: namespace websocket { struct message { bool is_binary() const; bool is_text() const; std::string_view operator*() const; }; struct event { bool is_error() const; bool is_message() const; error_code const&amp; error() const; message const&amp; message() const; }; struct connection { /// Schedule a frame to be sent at some point in the near future void send(std::string_view data, bool as_text = true); /// Suspend and wait until either there is a message available or an error net::awaitable&lt;event&gt; consume(); /// Close the websocket and suspend until it is closed. net::awaitable&lt;void&gt; close(beast::websocket::close_reason = /* a sensible default */); /// Send the close frame to the server but don&#39;t hang around to wait /// for the confirmation. void drop(beast::websocket::close_reason = /* a sensible default */); /// If consume() exits with an error of beast::websocket::error::closed then this /// will return the reason for the closure as sent by the server. /// Otherwise undefined. beast::websocket::close_reason reason() const; }; net::awaitable&lt;connection&gt; connect(std::string url, connect_options options /* = some default */); } The idea here is to keep the interface as lightweight and as simple as possible. The websocket connection will run on the executor of the coroutine that created it. Any commands sent to the websocket will be executor safe. That is, internally their work will be dispatched to the websocket connection’s executor. The exception to this will be the close_reason method, which must only be called once the connection’s consume coroutine has returned an error event. It is a guarantee that once consume returns an event that is an error, it will never return anything else, and no other method on the connection will mutate its internal state. In this condition, it is legal to call the reason method. A typical use would look like this: // default options auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); for(;;) { auto event = co_await ws.consume(); if (event.is_error()) break; else on_message(std::move(event.message())); } The above code example does not provide any means to write to the websocket. But it would be trivial to either spawn another coroutine to handle the writer, or call a function in order to signal some orthogonal process that the websocket was ready. // default options auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); on_connected(ws); // The websocket object should be shared-copyable for(;;) { auto event = co_await ws.consume(); if (event.is_error()) { on_close(); break; } else on_message(std::move(event.message())); } Another way to visualise a websocket is exactly as javascript’s websocket connection does, using callbacks or continuations in order to notify user code that the websocket has received data or closed. It would be trivial to wrap our coroutine version in order to provide this functionality. We would need to spawn a coroutine in order to run the consume() loop and then somehow signal it to stop if the websocket was disposed of. User code might then start to look something like this: websocket::connect(&quot;wss://echo.websocket.org&quot;, options) .on_connect([](websocket::connection ws) { run_my_loop(ws); }); void run_my_loop(websocket::connection ws) { bool closed = false; ws.on_close([&amp;]{ closed = true; }); ws.on_error([&amp;]{ closed = true; }); ws.on_message([&amp;](websocket::message msg){ process_message(msg); }); // some time later ws.send(&quot;Hello, World!&quot;); } With this style of interface we would need some means of passing the executor on which the continuations would be invoked. A reasonable place to do this might be the options parameter. In the JavaScript style interface, it would be important to be able to detect when the websocket has gone out of scope and ensure that it closes correctly, otherwise we’ll have a rogue resource out there with no handle by which we can close it. This argues that the actual websocket::connection class should be a handle to an internal implementation and that the destructor of the handle should ensure that the implementation is signalled so that it can drop the connection and shutdown cleanly. Under the covers, we’re implementing this websocket in Boost.Beast. As with all Asio objects, there could be (probably will be) asynchronous operations in progress at the time the websocket handle goes out of scope. Thinking this through, it means that: The implementation is going to live longer than the lifetime of the last copy of the handle owning the implementation. There needs to be some mechanism to cancel the underlying implementation’s operations. Coroutines can be visualised as threads of execution. In the world of threads (e.g. std::thread) we have primitives such as std::stop_token and std::condition_variable. The C++ Standard Library does not yet have these primitives for coroutines. And if it did it would be questionable whether they would be suitable for networking code where coroutines are actually built on top of Asio composed operations. Does Asio itself provide anything we can use? Asio’s Hidden Asynchronous condition_variable The answer is surprisingly, yes. But not in the form I was expecting when I asked Chris Kohlhoff (Asio’s author and maintainer) about it. It turns out that asio’s timer models an asynchronous version of a condition variable perfectly. Consider: Given: auto t = net::steady_timer(co_await net::this_coro::executor); t.expires_at(std::chrono::stready_clock::time_point::max()); Then we can write: template&lt;class Pred&gt; net::awaitable&lt;void&gt; wait(net::steady_timer&amp; t, Pred predicate) { error_code ec; while(!ec &amp;&amp; !predicate()) { co_await t.async_wait(net::redirect_error(net::use_awaitable, ec)); if (ec == net::error::operation_aborted) // timer cancelled continue; else throw std::logic_error(&quot;unexpected error&quot;); } } void notify(net::steady_timer&amp; t) { // assuming we are executing on the same executor as the wait() t.cancel(); } Which gives us a simple asynchronous condition_variable (this one does not implement timeouts, but it would be trivial to extend this code to accommodate them). Asynchronous Stop Token The std::stop_token is a welcome addition to the standard, but it is a little heavyweight for asynchronous code that runs in an executor, which is already thread-safe by design. A simple in-executor stop source can be implemented something like this: namespace async { namespace detail { struct shared_state { void stop() { if (!std::exchange(stopped_, true)) { auto sigs = std::move(signals_); signals_.clear(); for(auto&amp; s : sigs) s(); } } std::list&lt;std::function&lt;void()&gt;&gt; signals_; bool stopped_ = false; }; } struct stop_source { void stop() { impl_-&gt;stop(); } std::shared_ptr&lt;shared_state&gt; impl_; } struct stop_connection { }; struct stop_token { stop_token(stop_source&amp; source) : impl_(source.impl_) { } bool stopped() const { return !impl_ || impl_-&gt;stopped_; } stop_connection connect(std::function&lt;void()&gt; slot); std::shared_ptr&lt;shared_state&gt; impl_; } } The use case would look something like this: net::awaitable&lt;void&gt; something_with_websocket(async::stop_token token) { // passing the stop token allows the connect call to abort early // if the owner of the stop_source wants to end the use of the // websocket before it is connected auto ws = websocket::connect(&quot;wss://echo.websocket.org&quot;, websocket::connect_options { .stop_token = token }); // connect a slot to the stop token which drops the connection auto stopconn = token.connect([&amp;] { ws.drop(); }; for(;;} { auto event = co_await ws.consume(); // ...etc } } Now, armed with both a stop_token and a condition_variable, we gain a great deal of flexibility with programs running on an Asio-style executor. So let’s build a little chat app to talk the the echo bot. Coding style when using Asio coroutines. I mentioned earlier that I like to decompose objects with complex lifetimes into an impl and handle. My personal programming style for naming the components is as follows: The implementation This is the class that implements the complex functionality that we want. I generally give this class an _impl suffix and apply the following guidelines: The impl does not control its own lifetime. Calls to the impl are expected to already be executing on the correct thread or strand, and in the case of multi-threaded code, are expected to have already taken a lock on any mutex. This is a personal preference which I find tends to lower the complexity of the object, since the interface functions do not have to manage more than one concern, and deadlocks etc are not possible. The lifetime When holding an object in shared_ptr, we get a chance to intercept the destruction of the last handle. At this point we do not have to destroy the implementation, but can allow it to shut down gracefully before destruction. In order to do this, particularly with an object that is referenced by internal coroutines, I have found that it’s useful to separate the public lifetime of the object, and its internal lifetime, which may be longer than the public one. A convenient, if not especially efficient way to do this is to hold two shared_ptr’s in the handle. One being a shared_ptr which has a custom destructor - the lifetime ptr, and one being a normal shared_ptr to the implementation which can be copied in order to extend its private lifetime while it shuts down. It is the responsibility of the custom deleter to signal the implementation that it should start shutting down. In this case, the websocket connection’s public handle may look something like this: namespace websocket { struct connection_lifetime { connection_lifetime(std::shared_ptr&lt;connection_impl&gt;&amp;&amp; adopted) : impl_(std::move(adopted)) , lifetime_(new_lifetime(impl_)) { } static std::shared_ptr&lt;void&gt; new_lifetime(std::shared_ptr&lt;connection_impl&gt; const&amp; impl) { static int useful_address; auto deleter = [impl](int*) noexcept { net::co_spawn(impl-&gt;get_executor(), [impl]() -&gt; net::awaitable&lt;void&gt; { co_await impl-&gt;stop(); }, net::detached); }; return std::shared_ptr&lt;void&gt;(&amp;useful_address, deleter); } std::shared_ptr&lt;connection_impl&gt; impl_; std::shared_ptr&lt;void&gt; lifetime_; }; struct connection { connection(connection_lifetime l); }; } The interesting part here is in the function new_lifetime. There are a few things going on here. First, we are capturing the internal lifetime of our connection_impl and storing it in the deleter of the lifetime pointer. This of course means that the private implementation will live at least as long as the public lifetime. Secondly, the deleter does not actually delete anything. It merely captures a copy of the impl pointer and runs a coroutine on the impl to completion before releasing the impl pointer. The idea is that this coroutine will not complete until all internal coroutines within the implementation have completed. The provides the fortunate side effect that operations running inside the impl do not have to capture the impl’s lifetime via shared_from_this. It turns out that this aids composability, since subordinate coroutines within the implementation can be written as free functions, and ported to other implementations that may not involve a shared_ptr. It also means that the impl itself can be composed, since it has no restrictions on lifetime semantics. i.e. If I wanted to implement a JSON-RPC connection by deriving from the websocket::connection_impl, I do not have to be concerned about translating shared_ptrs internally in the derived class. Once it’s all put together Finally, having created all the primitives (which I really should start collating into a library), we can test our little websocket chat client, which becomes a very simple program: Here’s main: int main() { net::io_context ioctx; net::co_spawn( ioctx.get_executor(), [] { return chat(); }, net::detached); ioctx.run(); } And here’s the chat() coroutine: net::awaitable&lt; void &gt; chat() { // connect the websocket auto ws = co_await websocket::connect(&quot;wss://echo.websocket.org&quot;); // spawn the coroutine to read console input and send it to the websocket auto stop_children = async::stop_source(); net::co_spawn( co_await net::this_coro::executor, [stop = async::stop_token(stop_children), ws]() mutable { return do_console(std::move(stop), std::move(ws)); }, net::detached); // read events from the websocket connection. for (;;) { auto event = co_await ws.consume(); if (event.is_error()) { if (event.error() == beast::websocket::error::closed) std::cerr &lt;&lt; &quot;peer closed connection: &quot; &lt;&lt; ws.reason() &lt;&lt; std::endl; else std::cerr &lt;&lt; &quot;connection error: &quot; &lt;&lt; event.error() &lt;&lt; std::endl; break; } else { std::cout &lt;&lt; &quot;message received: &quot; &lt;&lt; event.message() &lt;&lt; std::endl; } } // at this point, the stop_source goes out of scope, // which will cause the console coroutine to exit. } And finally, the do_console() coroutine. Note that I have used asio’s posix interface to collect console input. In order to run compile in a WIN32 environment, we’d need to do something different (suggestions welcome via PR!). net::awaitable&lt; void &gt; do_console(async::stop_token stop, websocket::connection ws) try { auto console = asio::posix::stream_descriptor( co_await net::this_coro::executor, ::dup(STDIN_FILENO)); auto stopconn = stop.connect([&amp;] { console.cancel(); }); std::string console_chars; while (!stop.stopped()) { auto line_len = co_await net::async_read_until(console, net::dynamic_buffer(console_chars), &#39;\\n&#39;, net::use_awaitable); auto line = console_chars.substr(0, line_len - 1); console_chars.erase(0, line_len); std::cout &lt;&lt; &quot;you typed this: &quot; &lt;&lt; line &lt;&lt; std::endl; ws.send(line); } } catch(...) { // error handling here } If you’d like to look into the complete code, submit a PR or offer some (probably well-deserved) criticism, you will find the code repository here.","@type":"BlogPosting","url":"http://cppalliance.org/richard/2020/12/22/RichardsDecemberUpdate.html","headline":"Richard’s November/December Update","dateModified":"2020-12-22T00:00:00+00:00","datePublished":"2020-12-22T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://cppalliance.org/richard/2020/12/22/RichardsDecemberUpdate.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->



<link href="/css/prism.css" rel="stylesheet">


<link href='/feed.xml' rel='alternate' type='application/atom+xml'>

<!-- Twitter Card Start -->




  
    <meta name="twitter:image" content="https://cppalliance.org/images/logo.png">
  

<!-- Twitter Card End -->

<script defer data-domain="cppalliance.org" src="https://plausible.io/js/script.js"></script>

</head>

<body id='body' class="line-numbers">

  <!-- Navigation -->
  <nav class='nav dark'>
    <a href='/'>
      <img class='logo' alt='cpp-alliance-logo' src='/images/logo.svg' />
    </a>
    <div class='hamburger' id='nav-hamburger'>
      <span class='hamburger-line'></span>
      <span class='hamburger-line'></span>
      <span class='hamburger-line'></span>
    </div>
    <div class='nav-items' id='nav-items'>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/">Home</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#mission">Mission</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#team">Team</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#news">News</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#links">Links</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#faq">FAQ</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#contact">Contact</a></div>
      <div class='socials'>
        <div class='connect-content'>
          <div class='row row-sm'>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://github.com/CPPAlliance">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img github' alt='github-logo' src='/images/icons/github.svg' />
                </div>
                <span class='social-icon-text'>GitHub</span>
              </a>
            </div>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://www.facebook.com/CPPAlliance/">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img facebook' alt='facebook-logo' src='/images/icons/facebook.svg' />
                </div>
                <span class='social-icon-text'>Facebook</span>
              </a>
            </div>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://x.com/cppalliance">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img twitter' alt='x-logo' src='/images/icons/twitter.svg' />
                </div>
                <span class='social-icon-text'>X</span>
              </a>
            </div>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://www.linkedin.com/in/cppalliance/">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img linkedin' alt='linkedin-logo' src='/images/icons/linkedin.svg' />
                </div>
                <span class='social-icon-text'>LinkedIn</span>
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>






  <div class='post'>
  <div class='current-article'>
    

    <section class='section article'>
      

      <article>
      <div class="title-section center">
        <h2 class='text-l news-title no-border'>Richard's November/December Update</h2>
        
        
                
                
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                    
                    
        

        

        
          <div class='author d-iblock'>
            <a class='link author-img-link' href="/people/richard">
              <img class='author-img' src='/images/people/richard.jpg' alt='Portrait of Richard Hodges' />
            </a>
            <span class='text-xxs author-name'>
                <a class='link' href="/people/richard">
                  Richard Hodges
                </a> &middot; Dec 22, 2020
            </span>
          </div>
        
      </div>
        <div class='text-xxs content-text generated-content'>
          <h1 id="a-coroutine-websocket-using-boost-beast">A Coroutine Websocket Using Boost Beast</h1>

<p>This month I thought I would present a little idea that I had a few months ago.</p>

<p>Boost.Beast is a very comprehensive and competent websocket implementation, but it is not what you might call
“straightforward” to use unless you are already wise in the ways of Asio.</p>

<p>Beast’s documentation and design makes no apology for this. There is a disclaimer in the 
<a href="https://www.boost.org/doc/libs/1_75_0/libs/beast/doc/html/beast/using_io/asio_refresher.html">documentation</a>:</p>
<blockquote>
  <p>To use Beast effectively, a prior understanding of Networking is required.</p>
</blockquote>

<p>This is worth taking seriously (and if you are not fully aware of how Asio works with respect to the posting of 
completion handlers onto the associated executor, this page is worth studying).</p>

<h2 id="the-interface">The Interface</h2>

<p>I wanted to model my websocket object’s interface roughly on the javascript websocket connection interface. There will
be a few differences of course, because the javascript version uses callbacks (or continuations) and I will be using 
C++ coroutines that execute on an Asio executor. In underlying implementation, these concepts are not actually that far
apart, since Asio awaitables are actually implemented in terms of the normal asio completion token/handler interaction.</p>

<p>Furthermore, I want my WebSocket’s connection phase to be cancellable.</p>

<p>My websocket interface will look something like this:</p>

<pre><code class="language-cpp">namespace websocket
{
    struct message 
    {
        bool is_binary() const;
        bool is_text() const;
        std::string_view operator*() const;
    }; 
    
    struct event 
    {
        bool is_error() const;
        bool is_message() const;
        error_code const&amp; error() const; 
        message const&amp; message() const;
    };
    
    struct connection
    {
        /// Schedule a frame to be sent at some point in the near future
        void 
        send(std::string_view data, bool as_text = true);

        /// Suspend and wait until either there is a message available or an error        
        net::awaitable&lt;event&gt; 
        consume();
        
        /// Close the websocket and suspend until it is closed.
        net::awaitable&lt;void&gt; 
        close(beast::websocket::close_reason = /* a sensible default */); 

        /// Send the close frame to the server but don't hang around to wait
        /// for the confirmation.
        void 
        drop(beast::websocket::close_reason = /* a sensible default */);

        /// If consume() exits with an error of beast::websocket::error::closed then this
        /// will return the reason for the closure as sent by the server.
        /// Otherwise undefined.        
        beast::websocket::close_reason
        reason() const;
    };
    
    net::awaitable&lt;connection&gt; 
    connect(std::string url, 
            connect_options options /* = some default */);
}
</code></pre>

<p>The idea here is to keep the interface as lightweight and as simple as possible. The websocket connection will run on 
the executor of the coroutine that created it. Any commands sent to the websocket will be executor safe. That is, 
internally their work will be dispatched to the websocket connection’s executor. The exception to this will be the 
close_reason method, which must only be called once the connection’s consume coroutine has returned an error event.
It is a guarantee that once <code>consume</code> returns an event that is an error, it will never return anything else, and no
other method on the connection will mutate its internal state. In this condition, it is legal to call the <code>reason</code> 
method.</p>

<p>A typical use would look like this:</p>

<pre><code class="language-cpp">    // default options
    auto ws = co_await websocket::connect("wss://echo.websocket.org"); 

    for(;;)
    {
        auto event = co_await ws.consume();
        if (event.is_error())
            break;
        else
            on_message(std::move(event.message()));
    }    
</code></pre>

<p>The above code example does not provide any means to write to the websocket. But it would be trivial to either spawn
another coroutine to handle the writer, or call a function in order to signal some orthogonal process that the websocket 
was ready.</p>

<pre><code class="language-cpp">    // default options
    auto ws = co_await websocket::connect("wss://echo.websocket.org"); 
    
    on_connected(ws); // The websocket object should be shared-copyable

    for(;;)
    {
        auto event = co_await ws.consume();
        if (event.is_error()) {
            on_close();
            break;
        }
        else
            on_message(std::move(event.message()));
    }    
</code></pre>

<p>Another way to visualise a websocket is exactly as javascript’s websocket connection does, using callbacks or 
continuations in order to notify user code that the websocket has received data or closed. It would be trivial to wrap
our coroutine version in order to provide this functionality. We would need to spawn a coroutine in order to run 
the <code>consume()</code> loop and then somehow signal it to stop if the websocket was disposed of.</p>

<p>User code might then start to look something like this:</p>

<pre><code class="language-cpp">    websocket::connect("wss://echo.websocket.org", options)
        .on_connect([](websocket::connection ws)
        {
            run_my_loop(ws);
        });
        
void run_my_loop(websocket::connection ws)
{
    bool closed = false;
    ws.on_close([&amp;]{ closed = true; });
    ws.on_error([&amp;]{ closed = true; });
    ws.on_message([&amp;](websocket::message msg){ process_message(msg); });

    // some time later
    ws.send("Hello, World!");
}
</code></pre>

<p>With this style of interface we would need some means of passing the executor on which the continuations would be 
invoked. A reasonable place to do this might be the <code>options</code> parameter.</p>

<p>In the JavaScript style interface, it would be important to be able to detect when the websocket has gone out of scope
and ensure that it closes correctly, otherwise we’ll have a rogue resource out there with no handle by which we can 
close it. This argues that the actual <code>websocket::connection</code> class should be a handle to an internal implementation
and that the destructor of the handle should ensure that the implementation is signalled so that it can <code>drop</code> the 
connection and shutdown cleanly. Under the covers, we’re implementing this websocket in Boost.Beast. As with all Asio
objects, there could be (probably will be) asynchronous operations in progress at the time the websocket handle goes 
out of scope.</p>

<p>Thinking this through, it means that:</p>
<ul>
  <li>The implementation is going to live longer than the lifetime of the last copy of the handle owning the implementation.</li>
  <li>There needs to be some mechanism to cancel the underlying implementation’s operations.</li>
</ul>

<p>Coroutines can be visualised as threads of execution. In the world of threads (e.g. <code>std::thread</code>) we have primitives
such as <code>std::stop_token</code> and <code>std::condition_variable</code>. The C++ Standard Library does not yet have these primitives
for coroutines. And if it did it would be questionable whether they would be suitable for networking code where 
coroutines are actually built on top of Asio composed operations. Does Asio itself provide anything we can use?</p>

<h2 id="asios-hidden-asynchronous-condition_variable">Asio’s Hidden Asynchronous condition_variable</h2>

<p>The answer is surprisingly, yes. But not in the form I was expecting when I asked Chris Kohlhoff (Asio’s author and 
maintainer) about it. It turns out that asio’s timer models an asynchronous version of a condition variable perfectly. 
Consider:</p>

<p>Given:</p>
<pre><code class="language-cpp">auto t = net::steady_timer(co_await net::this_coro::executor);
t.expires_at(std::chrono::stready_clock::time_point::max());
</code></pre>

<p>Then we can write:</p>

<pre><code class="language-cpp">template&lt;class Pred&gt;
net::awaitable&lt;void&gt;
wait(net::steady_timer&amp; t, Pred predicate)
{
    error_code ec;
    while(!ec &amp;&amp; !predicate())
    {
        co_await t.async_wait(net::redirect_error(net::use_awaitable, ec));
        if (ec == net::error::operation_aborted)
            // timer cancelled
            continue;
        else
            throw std::logic_error("unexpected error");
    } 
}

void
notify(net::steady_timer&amp; t)
{
    // assuming we are executing on the same executor as the wait()
    t.cancel();
}
</code></pre>

<p>Which gives us a simple asynchronous condition_variable (this one does not implement timeouts, but it would be trivial
to extend this code to accommodate them).</p>

<h2 id="asynchronous-stop-token">Asynchronous Stop Token</h2>

<p>The <code>std::stop_token</code> is a welcome addition to the standard, but it is a little heavyweight for asynchronous code that 
runs in an executor, which is already thread-safe by design. A simple in-executor stop source can be implemented 
something like this:</p>

<pre><code class="language-cpp">namespace async {
namespace detail {
struct shared_state {
    void stop()
    {
        if (!std::exchange(stopped_, true))
        {
            auto sigs = std::move(signals_);
            signals_.clear();
            for(auto&amp; s : sigs)
                s();
        }
    }
    
    std::list&lt;std::function&lt;void()&gt;&gt; signals_;
    bool stopped_ =  false;
};
}
struct stop_source {
    void stop() {
        impl_-&gt;stop();
    }
    std::shared_ptr&lt;shared_state&gt; impl_;
}

struct stop_connection
{
};

struct stop_token
{
    stop_token(stop_source&amp; source)
    : impl_(source.impl_) {
    }
    
    bool 
    stopped() const { return !impl_ || impl_-&gt;stopped_; }
    
    stop_connection 
    connect(std::function&lt;void()&gt; slot);
     
    std::shared_ptr&lt;shared_state&gt; impl_;
}
}
</code></pre>

<p>The use case would look something like this:</p>

<pre><code class="language-cpp">
net::awaitable&lt;void&gt;
something_with_websocket(async::stop_token token)
{
    // passing the stop token allows the connect call to abort early
    // if the owner of the stop_source wants to end the use of the
    // websocket before it is connected
    auto ws = websocket::connect("wss://echo.websocket.org", 
        websocket::connect_options { .stop_token = token });

    // connect a slot to the stop token which drops the connection        
    auto stopconn = token.connect([&amp;] { ws.drop(); };
    
    for(;;} {
        auto event = co_await ws.consume();
        // ...etc
    }
    
}   
</code></pre>

<p>Now, armed with both a <code>stop_token</code> and a <code>condition_variable</code>, we gain a great deal of flexibility with programs 
running on an Asio-style executor.</p>

<p>So let’s build a little chat app to talk the the echo bot.</p>

<h2 id="coding-style-when-using-asio-coroutines">Coding style when using Asio coroutines.</h2>

<p>I mentioned earlier that I like to decompose objects with complex lifetimes into an impl and handle. My personal 
programming style for naming the components is as follows:</p>

<h3 id="the-implementation">The implementation</h3>

<p>This is the class that implements the complex functionality that we want. I generally give this class an <code>_impl</code> suffix
and apply the following guidelines:</p>
<ul>
  <li>The impl does not control its own lifetime.</li>
  <li>Calls to the impl are expected to already be executing on the correct thread or strand, and in the case of 
multi-threaded code, are expected to have already taken a lock on any mutex.</li>
</ul>

<p>This is a personal preference which I find tends to lower the complexity of the object, since the interface functions
do not have to manage more than one concern, and deadlocks etc are not possible.</p>

<h3 id="the-lifetime">The lifetime</h3>

<p>When holding an object in shared_ptr, we get a chance to intercept the destruction of the last handle. At this point
we do not have to destroy the implementation, but can allow it to shut down gracefully before destruction.
In order to do this, particularly with an object that is referenced by internal coroutines, I have found that it’s 
useful to separate the public lifetime of the object, and its internal lifetime, which may be longer than the public 
one.</p>

<p>A convenient, if not especially efficient way to do this is to hold two shared_ptr’s in the handle. One being a
shared_ptr<void> which has a custom destructor - the lifetime ptr, and one being a normal shared_ptr to the 
implementation which can be copied in order to extend its private lifetime while it shuts down.
It is the responsibility of the custom deleter to signal the implementation that it should start shutting down.</void></p>

<p>In this case, the websocket connection’s public handle may look something like this:</p>

<pre><code class="language-cpp">namespace websocket {

struct connection_lifetime
{
    connection_lifetime(std::shared_ptr&lt;connection_impl&gt;&amp;&amp; adopted)
    : impl_(std::move(adopted))
    , lifetime_(new_lifetime(impl_))
    {
    }
    
    static std::shared_ptr&lt;void&gt;
    new_lifetime(std::shared_ptr&lt;connection_impl&gt; const&amp; impl)
    {
        static int useful_address;
        auto deleter = [impl](int*) noexcept
        {
            net::co_spawn(impl-&gt;get_executor(), 
                [impl]() -&gt; net::awaitable&lt;void&gt;
                { 
                    co_await impl-&gt;stop();
                }, net::detached);
        };
        
        return std::shared_ptr&lt;void&gt;(&amp;useful_address, deleter);
    }
    
    std::shared_ptr&lt;connection_impl&gt; impl_;
    std::shared_ptr&lt;void&gt; lifetime_;
};

struct connection
{
    connection(connection_lifetime l);
};
}
</code></pre>

<p>The interesting part here is in the function <code>new_lifetime</code>. There are a few things going on here.
First, we are capturing the internal lifetime of our <code>connection_impl</code> and storing it in the deleter of the lifetime 
pointer. This of course means that the private implementation will live at least as long as the public lifetime.
Secondly, the deleter does not actually delete anything. It merely captures a copy of the impl pointer and runs a 
coroutine on the impl to completion before releasing the impl pointer. The idea is that this coroutine will not complete
until all internal coroutines within the implementation have completed. The provides the fortunate side effect that
operations running inside the impl do not have to capture the impl’s lifetime via shared_from_this.
It turns out that this aids composability, since subordinate coroutines within the implementation can be written as free
functions, and ported to other implementations that may not involve a shared_ptr.
It also means that the impl itself can be composed, since it has no restrictions on lifetime semantics.
i.e. If I wanted to implement a JSON-RPC connection by deriving from the websocket::connection_impl, I do not have to 
be concerned about translating shared_ptrs internally in the derived class.</p>

<h1 id="once-its-all-put-together">Once it’s all put together</h1>

<p>Finally, having created all the primitives (which I really should start collating into a library), we can test our
little websocket chat client, which becomes a very simple program:</p>

<p>Here’s main:</p>
<pre><code class="language-cpp">int
main()
{
    net::io_context ioctx;

    net::co_spawn(
        ioctx.get_executor(), [] { return chat(); }, net::detached);

    ioctx.run();
}
</code></pre>

<p>And here’s the chat() coroutine:</p>

<pre><code class="language-cpp">net::awaitable&lt; void &gt;
chat()
{
    // connect the websocket
    auto ws = co_await websocket::connect("wss://echo.websocket.org");

    // spawn the coroutine to read console input and send it to the websocket
    auto stop_children = async::stop_source();
    net::co_spawn(
        co_await net::this_coro::executor,
        [stop = async::stop_token(stop_children), ws]() mutable {
            return do_console(std::move(stop), std::move(ws));
        },
        net::detached);

    // read events from the websocket connection.
    for (;;)
    {
        auto event = co_await ws.consume();
        if (event.is_error())
        {
            if (event.error() == beast::websocket::error::closed)
                std::cerr &lt;&lt; "peer closed connection: " &lt;&lt; ws.reason()
                          &lt;&lt; std::endl;
            else
                std::cerr &lt;&lt; "connection error: " &lt;&lt; event.error() &lt;&lt; std::endl;
            break;
        }
        else
        {
            std::cout &lt;&lt; "message received: " &lt;&lt; event.message() &lt;&lt; std::endl;
        }
    }
    
    // at this point, the stop_source goes out of scope, 
    // which will cause the console coroutine to exit.
}
</code></pre>

<p>And finally, the do_console() coroutine. Note that I have used asio’s posix interface to collect console input. 
In order to run compile in a WIN32 environment, we’d need to do something different (suggestions welcome via PR!).</p>

<pre><code class="language-cpp">net::awaitable&lt; void &gt;
do_console(async::stop_token stop, websocket::connection ws)
try
{
    auto console = asio::posix::stream_descriptor(
        co_await net::this_coro::executor, ::dup(STDIN_FILENO));
    auto stopconn = stop.connect([&amp;] { console.cancel(); });

    std::string console_chars;
    while (!stop.stopped())
    {
        auto line_len =
            co_await net::async_read_until(console,
                                           net::dynamic_buffer(console_chars),
                                           '\n',
                                           net::use_awaitable);
        auto line = console_chars.substr(0, line_len - 1);
        console_chars.erase(0, line_len);
        std::cout &lt;&lt; "you typed this: " &lt;&lt; line &lt;&lt; std::endl;
        ws.send(line);
    }
}
catch(...) {
  // error handling here
}
</code></pre>

<p>If you’d like to look into the complete code, submit a PR or offer some (probably well-deserved) criticism, you will
find the <a href="https://github.com/madmongo1/blog-december-2020">code repository here</a>.</p>

        </div>
      </article>
    </section>
  </div>

  <section class="section news bottom-layout" id='news'>
    <div class='section-title'>
      <h2 class='header text-xl recent-post-header'>All Posts by This Author</h2>
    </div>
    <div class='news-content formatted-text'>
      <ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>08/10/2022</span>
          <a class='text-l news-title link' href="/richard/2022/08/10/RichardsAugustUpdate.html">Richard's August Update</a>
        </li>
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>10/10/2021</span>
          <a class='text-l news-title link' href="/richard/2021/10/10/RichardsOctoberUpdate.html">Richard's October Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>05/30/2021</span>
          <a class='text-l news-title link' href="/richard/2021/05/30/RichardsMayUpdate.html">Richard's May 2021 Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>04/30/2021</span>
          <a class='text-l news-title link' href="/richard/2021/04/30/RichardsAprilUpdate.html">Richard's April Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>03/30/2021</span>
          <a class='text-l news-title link' href="/richard/2021/03/30/RichardsMarchUpdate.html">Richard's February/March Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>01/31/2021</span>
          <a class='text-l news-title link' href="/richard/2021/01/31/RichardsJanuaryUpdate.html">Richard's January Update</a>
        </li>
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>01/01/2021</span>
          <a class='text-l news-title link' href="/richard/2021/01/01/RichardsNewYearUpdate.html">Richard's New Year Update - Reusable HTTP Connections</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>12/22/2020</span>
          <a class='text-l news-title link' href="/richard/2020/12/22/RichardsDecemberUpdate.html">Richard's November/December Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>10/31/2020</span>
          <a class='text-l news-title link' href="/richard/2020/10/31/RichardsOctoberUpdate.html">Richard's October Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>09/30/2020</span>
          <a class='text-l news-title link' href="/richard/2020/09/30/RichardsSeptemberUpdate.html">Richard's September Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>09/01/2020</span>
          <a class='text-l news-title link' href="/richard/2020/09/01/RichardsAugustUpdate.html">Richard's August Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>08/01/2020</span>
          <a class='text-l news-title link' href="/richard/2020/08/01/RichardsJulyUpdate.html">Richard's July Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>07/01/2020</span>
          <a class='text-l news-title link' href="/richard/2020/07/01/RichardsJuneUpdate.html">Richard's May/June Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>04/30/2020</span>
          <a class='text-l news-title link' href="/richard/2020/04/30/RichardsAprilUpdate.html">Richard's April Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>03/31/2020</span>
          <a class='text-l news-title link' href="/richard/2020/03/31/RichardsMarchUpdate.html">Richard's March Update</a>
        </li>
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>02/29/2020</span>
          <a class='text-l news-title link' href="/richard/2020/02/29/RichardsFebruaryUpdate.html">Richard's February Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>01/31/2020</span>
          <a class='text-l news-title link' href="/richard/2020/01/31/RichardsJanuaryUpdate.html">Richard's January Update</a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li>
          <a class='text-l all link' href="/news">View All Posts...</a>
        </li>
      </ul>
    </div>
  </section>

</div>


  <footer class='footer'>
    <p class='text-xxs footer-text'>
      <span class='line'>&copy; 2024 The C Plus Plus Alliance, Inc.</span>
      <span class='line'>Contact us at: <a href='mailto:%69%6E%66%6F@%63%70%70%61%6C%6C%69%61%6E%63%65.%6F%72%67'>info@cppalliance.org</a></span>
    </p>
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src='/js/main.js'></script>
  
  <script src='/js/prism.js'></script>
  

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-76438364-18', 'auto');
    ga('send', 'pageview');
  </script>

</body>
</html>
