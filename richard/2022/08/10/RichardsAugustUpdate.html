<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Richard's August Update | The C++ Alliance</title>
<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
<!-- Bootstrap core CSS -->
<link href="/css/style.css" rel="stylesheet">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=1">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=1">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=1">
<link rel="manifest" href="/site.webmanifest?v=1">
<link rel="mask-icon" href="/safari-pinned-tab.svg?v=1" color="#a91c20">
<link rel="shortcut icon" href="/favicon.ico?v=1">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="theme-color" content="#ffffff">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Richard’s August Update | The C++ Alliance</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Richard’s August Update" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Beast and HTTP Redirect Some months ago, I was asked how to handle HTTP redirect responses in beast. Characteristically, I took a moment to model how I would do that in my head, waved my hands and kind of explained it and that was that. Then more recently, someone else asked how beast websockets would handle a redirect response when performing a websocket handshake. Now I’m pretty sure that websocket clients have no requirement at all to follow redirects. I believe the WebSocket specification does not allow for such things, but I thought it would be an interesting exercise to cover the topic and provide a working code example and cover it in a blog post. There are a few reasons I decided to do this: Redirects are going to be important for any client-side framework written on Beast. There are a few new features in Asio which I thought it would be interesting to showcase. Code Repositiory The code for this blog can be found here. I have tested it on Fedora 36 and GCC-12. The code requires at least boost-1.80.0.beta1, because it takes advantage of the new change in Asio, which allows the deferred object returned by the asio::deferred completion token to be directly co_awaited. This provides a significant improvement in performance for operations that don’t need the full functionality of the asio::awaitable&lt;&gt; type. Handling a Redirect - General Case Redirects can be followed with the following generalised algorithm: set redirect count to 0 while not connected, no egregious errors and redirect limit has not been exceeded: crack URL resolve the FQDN of the host specified in the URL connect to the host if URL indicates HTTPS: negotiate TLS endif send http request (upgrade request for websocket) await response if response is 200ish: exit success elseif response is redirect: increment redirect count update URL with data found in Location header field continue else exit error endif endwhile Handling a Redirect in C++ with Beast It turns out that the entire process can be handled in one coroutine. Now remember that an HTTP connection can redirect to an HTTPS connection. So the “connection” type returned from a coroutine that creates a connection, having taken into account any redirects, must handle both transport types. It’s worth mentioning at this point that if you’re writing for a modern Linux kernel, TLS is now supported natively by the berkley sockets interface. This means that programs need no longer generate one code path for SSL and one for TCP. If this is interesting to you, there is some documentation here. When I get a moment I will create a modified copy of this program that uses Kernel TLS. However, for now, we do it the old-fashioned portable way. A connection abstraction First we define some useful types for our variant implementation struct websock_connection { using ws_stream = beast::websocket::stream&lt; tcp::socket &gt;; using wss_stream = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;; using var_type = boost::variant2::variant&lt; ws_stream, wss_stream &gt;; …provide TLS and SSL constructors… websock_connection(tcp::socket sock) : var_(ws_stream(std::move(sock))) { } websock_connection(ssl::stream&lt; tcp::socket &gt; stream) : var_(wss_stream(std::move(stream))) { } …provide access to the underlying (optional) SSL and TCP streams… tcp::socket &amp; sock(); ssl::stream&lt; tcp::socket &gt; * query_ssl(); … provide functions that return awaitables for the high level functions we will need… asio::awaitable&lt; void &gt; try_handshake(error_code &amp;ec, beast::websocket::response_type &amp;response, std::string hostname, std::string target); asio::awaitable&lt; std::size_t &gt; send_text(std::string const &amp;msg); asio::awaitable&lt; std::string &gt; receive_text(); asio::awaitable&lt; void &gt; close(beast::websocket::close_reason const &amp;reason); …and finally the implementation details… var_type var_; beast::flat_buffer rxbuffer_; }; The implementation of the various member functions are then all defined in terms of visit, e.g.: asio::awaitable&lt; std::size_t &gt; websock_connection::send_text(std::string const &amp;msg) { using asio::use_awaitable; return visit( [&amp;](auto &amp;ws) { ws.text(); return ws.async_write(asio::buffer(msg), use_awaitable); }, var_); } Note that this function is not actually a coroutine. Since it doesn’t maintain any state during the async operation, the function can simply return the awaitable to the calling coroutine. This saves the creation of a coroutine frame when we don’t need it. The interface and implementation for this class can be found in websocket_connection.[ch]pp in the git repo linked above. Moveable ssl::stream? You may have noticed something in this constructor: websock_connection(ssl::stream&lt; tcp::socket &gt; stream) : var_(wss_stream(std::move(stream))) { } I have std::move‘d the ssl stream into the WebSocket stream. Until a few versions ago, asio ssl streams were not moveable, which caused all kinds of issues when wanting to, for example, upgrade an SSL stream connection to a secure websocket stream. The Beast library has two workarounds for this: Beast provides its own version of ssl::stream, and beast::websocket::stream has a specialisation defined which holds a reference to a stream. These are probably now un-necessary and could arguably be deprecated. The algorithm in C++20 asio::awaitable&lt; std::unique_ptr&lt; websock_connection &gt; &gt; connect_websock(ssl::context &amp;sslctx, std::string urlstr, int const redirect_limit = 5) { using asio::experimental::deferred; // for convenience, take a copy of the current executor auto ex = co_await asio::this_coro::executor; // number of redirects detected so far int redirects = 0; // build a resolver in order tp decode te FQDNs in urls auto resolver = tcp::resolver(ex); // in the case of a redirect, we will resume processing here again: fmt::print(&quot;attempting connection: {}\n&quot;, urlstr); // decode the URL into components auto decoded = decode_url(urlstr); This part of the code builds a unique pointer to an initialised websocket_connection object, initialised with either an SSL stream or a TCP stream as indicated by the result of cracking the URL. For brevity I have used a regex to crack the URL, but you should check out Vinnie Falco’s new Boost.URL candidate library here. Vinnie will be looking for reviewers during this library’s submission to Boost later this month, so do keep an eye out in the Boost mailing list. // build the appropriate websocket stream type depending on whether the URL // indicates a TCP or TLS transport auto result = decoded.transport == transport_type::tls ? std::make_unique&lt; websock_connection &gt;( ssl::stream&lt; tcp::socket &gt;(ex, sslctx)) : std::make_unique&lt; websock_connection &gt;(tcp::socket(ex)); Here we are awaiting a connect operation with the result of awaiting a resolve operation. Note the use of asio::experimental::deferred. deferred is quite a versatile completion token which can be used to: return an lightweight awaitable, as demonstrated here, return a function object which may be later called multiple times with another completion handler; effectively creating a curried initiation, be supplied with a completion handler up front in order to create a deferred sequence of chained asynchronous operations; allowing simple composed operations to be built quickly and easily. // connect the underlying socket of the websocket stream to the first // reachable resolved endpoint co_await asio::async_connect( result-&gt;sock(), co_await resolver.async_resolve( decoded.hostname, decoded.service, deferred), deferred); In the case that the endpoint we are connecting to is secure, we must do the SSL/TLS handshake: // if the connection is TLS, we will want to update the hostname if (auto *tls = result-&gt;query_ssl(); tls) { if (!SSL_set_tlsext_host_name(tls-&gt;native_handle(), decoded.hostname.c_str())) throw system_error( error_code { static_cast&lt; int &gt;(::ERR_get_error()), asio::error::get_ssl_category() }); co_await tls-&gt;async_handshake(ssl::stream_base::client, deferred); } // some variables to receive the result of the handshake attempt auto ec = error_code(); auto response = beast::websocket::response_type(); The function try_handshake simply initiates the form of websocket handshake operation which preserves the http response returned from the server. We will need this in case the websocket connection response is actually a redirect. // attempt a websocket handshake, preserving the response fmt::print(&quot;...handshake\n&quot;); co_await result-&gt;try_handshake( ec, response, decoded.hostname, decoded.path_etc); // in case of error, we have three scenarios, detailed below: if (ec) { fmt::print(&quot;...error: {}\n{}&quot;, ec.message(), stitch(response.base())); auto http_result = response.result_int(); switch (response.result()) { And here is the code that handles the actual redirect. Note that in this simplistic implementation, I am replacing the URL with the Location field in the web server’s response. In reality, the returned URL could be a relative URL which would need to be merged into the original URL. Boost.URL handles this nicely. Once that library is available I’ll upgrade this example. case beast::http::status::permanent_redirect: case beast::http::status::temporary_redirect: case beast::http::status::multiple_choices: case beast::http::status::found: case beast::http::status::see_other: case beast::http::status::moved_permanently: // // Scenario 1: We have been redirected // if (response.count(beast::http::field::location)) { if (++redirects &lt;= redirect_limit) { // perform the redirect by updating the URL and jumping to // the goto label above. auto &amp;loc = response[beast::http::field::location]; urlstr.assign(loc.begin(), loc.end()); goto again; } else { throw std::runtime_error(&quot;too many redirects&quot;); } } else { // // Scenario 2: we have some other HTTP response which is not an // upgrade // throw system_error(ec, stitch(&quot;malformed redirect\r\n&quot;, response)); } break; default: // // Scenario 3: Some other transport error // throw system_error(ec, stitch(response)); } } else { // // successful handshake // fmt::print(&quot;...success\n{}&quot;, stitch(response.base())); } co_return result; } So with that written, all we need to do is write a simple coroutine to connect, chat and disconnect in order to test: asio::awaitable&lt; void &gt; comain(ssl::context &amp;sslctx, std::string initial_url) { auto connection = co_await connect_websock(sslctx, initial_url, 6); co_await echo(*connection, &quot;Hello, &quot;); co_await echo(*connection, &quot;World!\n&quot;); co_await connection-&gt;close(beast::websocket::close_reason( beast::websocket::close_code::going_away, &quot;thanks for the chat!&quot;)); co_return; } A Simple Http/WebSocket Server In order to test this code, I put together a super-simple web server, which is included in the repo and run as part of the demo program. This web server runs two coroutines, each with its own acceptor. One is the acceptor for HTTP/WS connections and the other is for HTTPS/WSS connections. Of course I could have used beast’s flex helper to auto-deduce WS/WSS on the same port, but I wanted to keep the implementation as simple as possible. The HTTP server is very simple. All it does is redirect the caller to the same Target on the WSS server: asio::awaitable&lt; void &gt; serve_http(tcp::socket sock, std::string https_endpoint) { using asio::experimental::deferred; auto rxbuf = beast::flat_buffer(); auto parser = beast::http::request_parser&lt; beast::http::empty_body &gt;(); co_await beast::http::async_read(sock, rxbuf, parser, deferred); static const auto re = std::regex(&quot;(/websocket-\\d+)(/.*)?&quot;, std::regex_constants::icase | std::regex_constants::optimize); auto match = std::cmatch(); auto &amp;request = parser.get(); if (std::regex_match( request.target().begin(), request.target().end(), match, re)) { co_await send_redirect( sock, fmt::format(&quot;{}{}&quot;, https_endpoint, match[0].str())); } else { co_await send_error( sock, beast::http::status::not_found, fmt::format(&quot;resource {} is not recognised\r\n&quot;, std::string_view(request.target().data(), request.target().size()))); } } The WSS server is minutely more complex. It looks for a URL of the form /websocket-(\d+)(/.*)? where group 1 is the “index number” of the request. If the index number is 0, the websocket request is accepted and we head off into a chat coroutine for the remainder of the connection. If it is non-zero, then the index is decremented, the URL is reconstructed with the new index, and the redirect response is sent back. So if for example you requested http://some-server/websocket-2/bar, you would be redirected along the following path: https://some-server/websocket-2/bar (first http to https transition) https://some-server/websocket-1/bar https://some-server/websocket-0/bar (websocket handshake accepted on this URL) Here’s the code: asio::awaitable&lt; void &gt; serve_https(ssl::stream&lt; tcp::socket &gt; stream, std::string https_fqdn) { try { using asio::experimental::deferred; co_await stream.async_handshake(ssl::stream_base::server, deferred); auto rxbuf = beast::flat_buffer(); auto request = beast::http::request&lt; beast::http::string_body &gt;(); co_await beast::http::async_read(stream, rxbuf, request, deferred); auto &amp;sock = stream.next_layer(); if (beast::websocket::is_upgrade(request)) { static const auto re = std::regex( &quot;/websocket-(\\d+)(/.*)?&quot;, std::regex_constants::icase | std::regex_constants::optimize); auto match = std::cmatch(); if (std::regex_match(request.target().begin(), request.target().end(), match, re)) { auto index = ::atoi(match[1].str().c_str()); if (index == 0) { auto wss = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;( std::move(stream)); co_await wss.async_accept(request, deferred); co_await run_echo_server(wss, rxbuf); // serve the websocket } else { // redirect to the next index down auto loc = fmt::format(&quot;{}/websocket-{}{}&quot;, https_fqdn, index - 1, match[2].str()); co_await send_redirect(stream, loc); } } else { co_await send_error(stream, beast::http::status::not_found, &quot;try /websocket-5\r\n&quot;); } } else { co_await send_error( stream, beast::http::status::not_acceptable, &quot;This server only accepts websocket requests\r\n&quot;); } } catch (system_error &amp;e) { fmt::print(&quot;serve_https: {}\n&quot;, e.code().message()); } catch (std::exception &amp;e) { fmt::print(&quot;serve_https: {}\n&quot;, e.what()); } The run_echo_server coroutine is about as simple as it gets. Note the use of deferred as a completion token in order to create the lightweight awaitable type. asio::awaitable&lt; void &gt; run_echo_server(beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt; &amp;wss, beast::flat_buffer &amp;rxbuf) { using asio::experimental::deferred; for (;;) { auto size = co_await wss.async_read(rxbuf, deferred); auto data = rxbuf.cdata(); co_await wss.async_write(data, deferred); rxbuf.consume(size); } } An Example of Cancellation The server is trivial, but there is one little feature I wanted to demonstrate. The purpose of the demo is: spin up a web server connect to the web server a few times and have a chat with it exit the program This then leaves the issue of causing the web server to shut down so as to release its ownership of the underlying io_context run operation. i.e. if the io_context doesn’t run out of work, the call to io_context::run() won’t return. I have taken advantage of the fact that when coroutines are spawned with an associated cancellation slot, the cancellation slot tree propagates down through all child coroutines and asio operations. So it becomes as simple as: Define a cancellation signal: auto stop_sig = asio::cancellation_signal(); Run the server, passing in the cancellation signal’s slot: svr.run(stop_sig.slot()); When the client code has completed, it simply needs to cause the signal to emit: co_spawn(ioc, comain(ioctx, initial_url), [&amp;](std::exception_ptr ep) { We emit the signal regardless of whether the client ended in an error or not - we want to stop the server in either case stop_sig.emit(asio::cancellation_type::all); try { if (ep) std::rethrow_exception(ep); } catch (std::exception &amp;e) { fmt::print(&quot;client exception: {}\n&quot;, e.what()); } }); Within the server, we spawn the internal coroutines bound to the cancellation slot. This will cause the slot to propagate the signal into the subordinate coroutines, causing whatever they are doing to complete with an operation_aborted error. void server::run(asio::cancellation_slot stop_slot) { awaitable_operators makes dealing with parallel coroutines extremely simple. using namespace asio::experimental::awaitable_operators; using asio::bind_cancellation_slot; using asio::co_spawn; using asio::use_awaitable; fmt::print(&quot;server starting\n&quot;); auto handler = [](std::exception_ptr ep) { try { if (ep) std::rethrow_exception(ep); } catch (asio::multiple_exceptions &amp;es) { print_exceptions(es.first_exception()); } catch (std::exception &amp;e) { print_exceptions(e); } }; Here we are creating an outer coroutine which represents the simultaneous execution of the two inner coroutines, http_server and wss_server. The completion token of this outer coroutine is bound to the supplied cancellation slot. When this slot is invoked, it will propagate the signal into the two subordinate coroutines. co_spawn(get_executor(), http_server(tcp_acceptor_, tls_root_) &amp;&amp; wss_server(sslctx_, tls_acceptor_, tls_root_), bind_cancellation_slot(stop_slot, handler)); } Final output Here is an example of the output generated by this program, tracking the various redirects and correct shutdown of all IO operations. $ ~/github/madmongo1/blog-2022-Aug-websock-redirect/cmake-build-debug/blog-2022-aug-websock-redirect Initialising server starting attempting connection: ws://127.0.0.1:38503/websocket-4 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-4 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-4 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-3 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-3 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-2 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-2 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-1 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-1 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-0 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-0 ...handshake ...success HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: upgrade Sec-WebSocket-Accept: N5wCr5WUOM6LxN8I4If7oR8QW3A= Server: Boost.Beast/330 Hello, World! serve_https: The WebSocket stream was gracefully closed at both endpoints http_server: Operation canceled wss_server: Operation canceled Finished Process finished with exit code 0 Final Note I have of course cut many corners in this demonstration. The error handling is a bit ropey and I haven’t considered timeouts, connection re-use, etc. But hopefully this will be useful to anyone reading. Until next time." />
<meta property="og:description" content="Beast and HTTP Redirect Some months ago, I was asked how to handle HTTP redirect responses in beast. Characteristically, I took a moment to model how I would do that in my head, waved my hands and kind of explained it and that was that. Then more recently, someone else asked how beast websockets would handle a redirect response when performing a websocket handshake. Now I’m pretty sure that websocket clients have no requirement at all to follow redirects. I believe the WebSocket specification does not allow for such things, but I thought it would be an interesting exercise to cover the topic and provide a working code example and cover it in a blog post. There are a few reasons I decided to do this: Redirects are going to be important for any client-side framework written on Beast. There are a few new features in Asio which I thought it would be interesting to showcase. Code Repositiory The code for this blog can be found here. I have tested it on Fedora 36 and GCC-12. The code requires at least boost-1.80.0.beta1, because it takes advantage of the new change in Asio, which allows the deferred object returned by the asio::deferred completion token to be directly co_awaited. This provides a significant improvement in performance for operations that don’t need the full functionality of the asio::awaitable&lt;&gt; type. Handling a Redirect - General Case Redirects can be followed with the following generalised algorithm: set redirect count to 0 while not connected, no egregious errors and redirect limit has not been exceeded: crack URL resolve the FQDN of the host specified in the URL connect to the host if URL indicates HTTPS: negotiate TLS endif send http request (upgrade request for websocket) await response if response is 200ish: exit success elseif response is redirect: increment redirect count update URL with data found in Location header field continue else exit error endif endwhile Handling a Redirect in C++ with Beast It turns out that the entire process can be handled in one coroutine. Now remember that an HTTP connection can redirect to an HTTPS connection. So the “connection” type returned from a coroutine that creates a connection, having taken into account any redirects, must handle both transport types. It’s worth mentioning at this point that if you’re writing for a modern Linux kernel, TLS is now supported natively by the berkley sockets interface. This means that programs need no longer generate one code path for SSL and one for TCP. If this is interesting to you, there is some documentation here. When I get a moment I will create a modified copy of this program that uses Kernel TLS. However, for now, we do it the old-fashioned portable way. A connection abstraction First we define some useful types for our variant implementation struct websock_connection { using ws_stream = beast::websocket::stream&lt; tcp::socket &gt;; using wss_stream = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;; using var_type = boost::variant2::variant&lt; ws_stream, wss_stream &gt;; …provide TLS and SSL constructors… websock_connection(tcp::socket sock) : var_(ws_stream(std::move(sock))) { } websock_connection(ssl::stream&lt; tcp::socket &gt; stream) : var_(wss_stream(std::move(stream))) { } …provide access to the underlying (optional) SSL and TCP streams… tcp::socket &amp; sock(); ssl::stream&lt; tcp::socket &gt; * query_ssl(); … provide functions that return awaitables for the high level functions we will need… asio::awaitable&lt; void &gt; try_handshake(error_code &amp;ec, beast::websocket::response_type &amp;response, std::string hostname, std::string target); asio::awaitable&lt; std::size_t &gt; send_text(std::string const &amp;msg); asio::awaitable&lt; std::string &gt; receive_text(); asio::awaitable&lt; void &gt; close(beast::websocket::close_reason const &amp;reason); …and finally the implementation details… var_type var_; beast::flat_buffer rxbuffer_; }; The implementation of the various member functions are then all defined in terms of visit, e.g.: asio::awaitable&lt; std::size_t &gt; websock_connection::send_text(std::string const &amp;msg) { using asio::use_awaitable; return visit( [&amp;](auto &amp;ws) { ws.text(); return ws.async_write(asio::buffer(msg), use_awaitable); }, var_); } Note that this function is not actually a coroutine. Since it doesn’t maintain any state during the async operation, the function can simply return the awaitable to the calling coroutine. This saves the creation of a coroutine frame when we don’t need it. The interface and implementation for this class can be found in websocket_connection.[ch]pp in the git repo linked above. Moveable ssl::stream? You may have noticed something in this constructor: websock_connection(ssl::stream&lt; tcp::socket &gt; stream) : var_(wss_stream(std::move(stream))) { } I have std::move‘d the ssl stream into the WebSocket stream. Until a few versions ago, asio ssl streams were not moveable, which caused all kinds of issues when wanting to, for example, upgrade an SSL stream connection to a secure websocket stream. The Beast library has two workarounds for this: Beast provides its own version of ssl::stream, and beast::websocket::stream has a specialisation defined which holds a reference to a stream. These are probably now un-necessary and could arguably be deprecated. The algorithm in C++20 asio::awaitable&lt; std::unique_ptr&lt; websock_connection &gt; &gt; connect_websock(ssl::context &amp;sslctx, std::string urlstr, int const redirect_limit = 5) { using asio::experimental::deferred; // for convenience, take a copy of the current executor auto ex = co_await asio::this_coro::executor; // number of redirects detected so far int redirects = 0; // build a resolver in order tp decode te FQDNs in urls auto resolver = tcp::resolver(ex); // in the case of a redirect, we will resume processing here again: fmt::print(&quot;attempting connection: {}\n&quot;, urlstr); // decode the URL into components auto decoded = decode_url(urlstr); This part of the code builds a unique pointer to an initialised websocket_connection object, initialised with either an SSL stream or a TCP stream as indicated by the result of cracking the URL. For brevity I have used a regex to crack the URL, but you should check out Vinnie Falco’s new Boost.URL candidate library here. Vinnie will be looking for reviewers during this library’s submission to Boost later this month, so do keep an eye out in the Boost mailing list. // build the appropriate websocket stream type depending on whether the URL // indicates a TCP or TLS transport auto result = decoded.transport == transport_type::tls ? std::make_unique&lt; websock_connection &gt;( ssl::stream&lt; tcp::socket &gt;(ex, sslctx)) : std::make_unique&lt; websock_connection &gt;(tcp::socket(ex)); Here we are awaiting a connect operation with the result of awaiting a resolve operation. Note the use of asio::experimental::deferred. deferred is quite a versatile completion token which can be used to: return an lightweight awaitable, as demonstrated here, return a function object which may be later called multiple times with another completion handler; effectively creating a curried initiation, be supplied with a completion handler up front in order to create a deferred sequence of chained asynchronous operations; allowing simple composed operations to be built quickly and easily. // connect the underlying socket of the websocket stream to the first // reachable resolved endpoint co_await asio::async_connect( result-&gt;sock(), co_await resolver.async_resolve( decoded.hostname, decoded.service, deferred), deferred); In the case that the endpoint we are connecting to is secure, we must do the SSL/TLS handshake: // if the connection is TLS, we will want to update the hostname if (auto *tls = result-&gt;query_ssl(); tls) { if (!SSL_set_tlsext_host_name(tls-&gt;native_handle(), decoded.hostname.c_str())) throw system_error( error_code { static_cast&lt; int &gt;(::ERR_get_error()), asio::error::get_ssl_category() }); co_await tls-&gt;async_handshake(ssl::stream_base::client, deferred); } // some variables to receive the result of the handshake attempt auto ec = error_code(); auto response = beast::websocket::response_type(); The function try_handshake simply initiates the form of websocket handshake operation which preserves the http response returned from the server. We will need this in case the websocket connection response is actually a redirect. // attempt a websocket handshake, preserving the response fmt::print(&quot;...handshake\n&quot;); co_await result-&gt;try_handshake( ec, response, decoded.hostname, decoded.path_etc); // in case of error, we have three scenarios, detailed below: if (ec) { fmt::print(&quot;...error: {}\n{}&quot;, ec.message(), stitch(response.base())); auto http_result = response.result_int(); switch (response.result()) { And here is the code that handles the actual redirect. Note that in this simplistic implementation, I am replacing the URL with the Location field in the web server’s response. In reality, the returned URL could be a relative URL which would need to be merged into the original URL. Boost.URL handles this nicely. Once that library is available I’ll upgrade this example. case beast::http::status::permanent_redirect: case beast::http::status::temporary_redirect: case beast::http::status::multiple_choices: case beast::http::status::found: case beast::http::status::see_other: case beast::http::status::moved_permanently: // // Scenario 1: We have been redirected // if (response.count(beast::http::field::location)) { if (++redirects &lt;= redirect_limit) { // perform the redirect by updating the URL and jumping to // the goto label above. auto &amp;loc = response[beast::http::field::location]; urlstr.assign(loc.begin(), loc.end()); goto again; } else { throw std::runtime_error(&quot;too many redirects&quot;); } } else { // // Scenario 2: we have some other HTTP response which is not an // upgrade // throw system_error(ec, stitch(&quot;malformed redirect\r\n&quot;, response)); } break; default: // // Scenario 3: Some other transport error // throw system_error(ec, stitch(response)); } } else { // // successful handshake // fmt::print(&quot;...success\n{}&quot;, stitch(response.base())); } co_return result; } So with that written, all we need to do is write a simple coroutine to connect, chat and disconnect in order to test: asio::awaitable&lt; void &gt; comain(ssl::context &amp;sslctx, std::string initial_url) { auto connection = co_await connect_websock(sslctx, initial_url, 6); co_await echo(*connection, &quot;Hello, &quot;); co_await echo(*connection, &quot;World!\n&quot;); co_await connection-&gt;close(beast::websocket::close_reason( beast::websocket::close_code::going_away, &quot;thanks for the chat!&quot;)); co_return; } A Simple Http/WebSocket Server In order to test this code, I put together a super-simple web server, which is included in the repo and run as part of the demo program. This web server runs two coroutines, each with its own acceptor. One is the acceptor for HTTP/WS connections and the other is for HTTPS/WSS connections. Of course I could have used beast’s flex helper to auto-deduce WS/WSS on the same port, but I wanted to keep the implementation as simple as possible. The HTTP server is very simple. All it does is redirect the caller to the same Target on the WSS server: asio::awaitable&lt; void &gt; serve_http(tcp::socket sock, std::string https_endpoint) { using asio::experimental::deferred; auto rxbuf = beast::flat_buffer(); auto parser = beast::http::request_parser&lt; beast::http::empty_body &gt;(); co_await beast::http::async_read(sock, rxbuf, parser, deferred); static const auto re = std::regex(&quot;(/websocket-\\d+)(/.*)?&quot;, std::regex_constants::icase | std::regex_constants::optimize); auto match = std::cmatch(); auto &amp;request = parser.get(); if (std::regex_match( request.target().begin(), request.target().end(), match, re)) { co_await send_redirect( sock, fmt::format(&quot;{}{}&quot;, https_endpoint, match[0].str())); } else { co_await send_error( sock, beast::http::status::not_found, fmt::format(&quot;resource {} is not recognised\r\n&quot;, std::string_view(request.target().data(), request.target().size()))); } } The WSS server is minutely more complex. It looks for a URL of the form /websocket-(\d+)(/.*)? where group 1 is the “index number” of the request. If the index number is 0, the websocket request is accepted and we head off into a chat coroutine for the remainder of the connection. If it is non-zero, then the index is decremented, the URL is reconstructed with the new index, and the redirect response is sent back. So if for example you requested http://some-server/websocket-2/bar, you would be redirected along the following path: https://some-server/websocket-2/bar (first http to https transition) https://some-server/websocket-1/bar https://some-server/websocket-0/bar (websocket handshake accepted on this URL) Here’s the code: asio::awaitable&lt; void &gt; serve_https(ssl::stream&lt; tcp::socket &gt; stream, std::string https_fqdn) { try { using asio::experimental::deferred; co_await stream.async_handshake(ssl::stream_base::server, deferred); auto rxbuf = beast::flat_buffer(); auto request = beast::http::request&lt; beast::http::string_body &gt;(); co_await beast::http::async_read(stream, rxbuf, request, deferred); auto &amp;sock = stream.next_layer(); if (beast::websocket::is_upgrade(request)) { static const auto re = std::regex( &quot;/websocket-(\\d+)(/.*)?&quot;, std::regex_constants::icase | std::regex_constants::optimize); auto match = std::cmatch(); if (std::regex_match(request.target().begin(), request.target().end(), match, re)) { auto index = ::atoi(match[1].str().c_str()); if (index == 0) { auto wss = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;( std::move(stream)); co_await wss.async_accept(request, deferred); co_await run_echo_server(wss, rxbuf); // serve the websocket } else { // redirect to the next index down auto loc = fmt::format(&quot;{}/websocket-{}{}&quot;, https_fqdn, index - 1, match[2].str()); co_await send_redirect(stream, loc); } } else { co_await send_error(stream, beast::http::status::not_found, &quot;try /websocket-5\r\n&quot;); } } else { co_await send_error( stream, beast::http::status::not_acceptable, &quot;This server only accepts websocket requests\r\n&quot;); } } catch (system_error &amp;e) { fmt::print(&quot;serve_https: {}\n&quot;, e.code().message()); } catch (std::exception &amp;e) { fmt::print(&quot;serve_https: {}\n&quot;, e.what()); } The run_echo_server coroutine is about as simple as it gets. Note the use of deferred as a completion token in order to create the lightweight awaitable type. asio::awaitable&lt; void &gt; run_echo_server(beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt; &amp;wss, beast::flat_buffer &amp;rxbuf) { using asio::experimental::deferred; for (;;) { auto size = co_await wss.async_read(rxbuf, deferred); auto data = rxbuf.cdata(); co_await wss.async_write(data, deferred); rxbuf.consume(size); } } An Example of Cancellation The server is trivial, but there is one little feature I wanted to demonstrate. The purpose of the demo is: spin up a web server connect to the web server a few times and have a chat with it exit the program This then leaves the issue of causing the web server to shut down so as to release its ownership of the underlying io_context run operation. i.e. if the io_context doesn’t run out of work, the call to io_context::run() won’t return. I have taken advantage of the fact that when coroutines are spawned with an associated cancellation slot, the cancellation slot tree propagates down through all child coroutines and asio operations. So it becomes as simple as: Define a cancellation signal: auto stop_sig = asio::cancellation_signal(); Run the server, passing in the cancellation signal’s slot: svr.run(stop_sig.slot()); When the client code has completed, it simply needs to cause the signal to emit: co_spawn(ioc, comain(ioctx, initial_url), [&amp;](std::exception_ptr ep) { We emit the signal regardless of whether the client ended in an error or not - we want to stop the server in either case stop_sig.emit(asio::cancellation_type::all); try { if (ep) std::rethrow_exception(ep); } catch (std::exception &amp;e) { fmt::print(&quot;client exception: {}\n&quot;, e.what()); } }); Within the server, we spawn the internal coroutines bound to the cancellation slot. This will cause the slot to propagate the signal into the subordinate coroutines, causing whatever they are doing to complete with an operation_aborted error. void server::run(asio::cancellation_slot stop_slot) { awaitable_operators makes dealing with parallel coroutines extremely simple. using namespace asio::experimental::awaitable_operators; using asio::bind_cancellation_slot; using asio::co_spawn; using asio::use_awaitable; fmt::print(&quot;server starting\n&quot;); auto handler = [](std::exception_ptr ep) { try { if (ep) std::rethrow_exception(ep); } catch (asio::multiple_exceptions &amp;es) { print_exceptions(es.first_exception()); } catch (std::exception &amp;e) { print_exceptions(e); } }; Here we are creating an outer coroutine which represents the simultaneous execution of the two inner coroutines, http_server and wss_server. The completion token of this outer coroutine is bound to the supplied cancellation slot. When this slot is invoked, it will propagate the signal into the two subordinate coroutines. co_spawn(get_executor(), http_server(tcp_acceptor_, tls_root_) &amp;&amp; wss_server(sslctx_, tls_acceptor_, tls_root_), bind_cancellation_slot(stop_slot, handler)); } Final output Here is an example of the output generated by this program, tracking the various redirects and correct shutdown of all IO operations. $ ~/github/madmongo1/blog-2022-Aug-websock-redirect/cmake-build-debug/blog-2022-aug-websock-redirect Initialising server starting attempting connection: ws://127.0.0.1:38503/websocket-4 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-4 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-4 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-3 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-3 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-2 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-2 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-1 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-1 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-0 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-0 ...handshake ...success HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: upgrade Sec-WebSocket-Accept: N5wCr5WUOM6LxN8I4If7oR8QW3A= Server: Boost.Beast/330 Hello, World! serve_https: The WebSocket stream was gracefully closed at both endpoints http_server: Operation canceled wss_server: Operation canceled Finished Process finished with exit code 0 Final Note I have of course cut many corners in this demonstration. The error handling is a bit ropey and I haven’t considered timeouts, connection re-use, etc. But hopefully this will be useful to anyone reading. Until next time." />
<link rel="canonical" href="http://cppalliance.org/richard/2022/08/10/RichardsAugustUpdate.html" />
<meta property="og:url" content="http://cppalliance.org/richard/2022/08/10/RichardsAugustUpdate.html" />
<meta property="og:site_name" content="The C++ Alliance" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Richard’s August Update" />
<meta name="twitter:site" content="@CPPAlliance" />
<script type="application/ld+json">
{"description":"Beast and HTTP Redirect Some months ago, I was asked how to handle HTTP redirect responses in beast. Characteristically, I took a moment to model how I would do that in my head, waved my hands and kind of explained it and that was that. Then more recently, someone else asked how beast websockets would handle a redirect response when performing a websocket handshake. Now I’m pretty sure that websocket clients have no requirement at all to follow redirects. I believe the WebSocket specification does not allow for such things, but I thought it would be an interesting exercise to cover the topic and provide a working code example and cover it in a blog post. There are a few reasons I decided to do this: Redirects are going to be important for any client-side framework written on Beast. There are a few new features in Asio which I thought it would be interesting to showcase. Code Repositiory The code for this blog can be found here. I have tested it on Fedora 36 and GCC-12. The code requires at least boost-1.80.0.beta1, because it takes advantage of the new change in Asio, which allows the deferred object returned by the asio::deferred completion token to be directly co_awaited. This provides a significant improvement in performance for operations that don’t need the full functionality of the asio::awaitable&lt;&gt; type. Handling a Redirect - General Case Redirects can be followed with the following generalised algorithm: set redirect count to 0 while not connected, no egregious errors and redirect limit has not been exceeded: crack URL resolve the FQDN of the host specified in the URL connect to the host if URL indicates HTTPS: negotiate TLS endif send http request (upgrade request for websocket) await response if response is 200ish: exit success elseif response is redirect: increment redirect count update URL with data found in Location header field continue else exit error endif endwhile Handling a Redirect in C++ with Beast It turns out that the entire process can be handled in one coroutine. Now remember that an HTTP connection can redirect to an HTTPS connection. So the “connection” type returned from a coroutine that creates a connection, having taken into account any redirects, must handle both transport types. It’s worth mentioning at this point that if you’re writing for a modern Linux kernel, TLS is now supported natively by the berkley sockets interface. This means that programs need no longer generate one code path for SSL and one for TCP. If this is interesting to you, there is some documentation here. When I get a moment I will create a modified copy of this program that uses Kernel TLS. However, for now, we do it the old-fashioned portable way. A connection abstraction First we define some useful types for our variant implementation struct websock_connection { using ws_stream = beast::websocket::stream&lt; tcp::socket &gt;; using wss_stream = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;; using var_type = boost::variant2::variant&lt; ws_stream, wss_stream &gt;; …provide TLS and SSL constructors… websock_connection(tcp::socket sock) : var_(ws_stream(std::move(sock))) { } websock_connection(ssl::stream&lt; tcp::socket &gt; stream) : var_(wss_stream(std::move(stream))) { } …provide access to the underlying (optional) SSL and TCP streams… tcp::socket &amp; sock(); ssl::stream&lt; tcp::socket &gt; * query_ssl(); … provide functions that return awaitables for the high level functions we will need… asio::awaitable&lt; void &gt; try_handshake(error_code &amp;ec, beast::websocket::response_type &amp;response, std::string hostname, std::string target); asio::awaitable&lt; std::size_t &gt; send_text(std::string const &amp;msg); asio::awaitable&lt; std::string &gt; receive_text(); asio::awaitable&lt; void &gt; close(beast::websocket::close_reason const &amp;reason); …and finally the implementation details… var_type var_; beast::flat_buffer rxbuffer_; }; The implementation of the various member functions are then all defined in terms of visit, e.g.: asio::awaitable&lt; std::size_t &gt; websock_connection::send_text(std::string const &amp;msg) { using asio::use_awaitable; return visit( [&amp;](auto &amp;ws) { ws.text(); return ws.async_write(asio::buffer(msg), use_awaitable); }, var_); } Note that this function is not actually a coroutine. Since it doesn’t maintain any state during the async operation, the function can simply return the awaitable to the calling coroutine. This saves the creation of a coroutine frame when we don’t need it. The interface and implementation for this class can be found in websocket_connection.[ch]pp in the git repo linked above. Moveable ssl::stream? You may have noticed something in this constructor: websock_connection(ssl::stream&lt; tcp::socket &gt; stream) : var_(wss_stream(std::move(stream))) { } I have std::move‘d the ssl stream into the WebSocket stream. Until a few versions ago, asio ssl streams were not moveable, which caused all kinds of issues when wanting to, for example, upgrade an SSL stream connection to a secure websocket stream. The Beast library has two workarounds for this: Beast provides its own version of ssl::stream, and beast::websocket::stream has a specialisation defined which holds a reference to a stream. These are probably now un-necessary and could arguably be deprecated. The algorithm in C++20 asio::awaitable&lt; std::unique_ptr&lt; websock_connection &gt; &gt; connect_websock(ssl::context &amp;sslctx, std::string urlstr, int const redirect_limit = 5) { using asio::experimental::deferred; // for convenience, take a copy of the current executor auto ex = co_await asio::this_coro::executor; // number of redirects detected so far int redirects = 0; // build a resolver in order tp decode te FQDNs in urls auto resolver = tcp::resolver(ex); // in the case of a redirect, we will resume processing here again: fmt::print(&quot;attempting connection: {}\\n&quot;, urlstr); // decode the URL into components auto decoded = decode_url(urlstr); This part of the code builds a unique pointer to an initialised websocket_connection object, initialised with either an SSL stream or a TCP stream as indicated by the result of cracking the URL. For brevity I have used a regex to crack the URL, but you should check out Vinnie Falco’s new Boost.URL candidate library here. Vinnie will be looking for reviewers during this library’s submission to Boost later this month, so do keep an eye out in the Boost mailing list. // build the appropriate websocket stream type depending on whether the URL // indicates a TCP or TLS transport auto result = decoded.transport == transport_type::tls ? std::make_unique&lt; websock_connection &gt;( ssl::stream&lt; tcp::socket &gt;(ex, sslctx)) : std::make_unique&lt; websock_connection &gt;(tcp::socket(ex)); Here we are awaiting a connect operation with the result of awaiting a resolve operation. Note the use of asio::experimental::deferred. deferred is quite a versatile completion token which can be used to: return an lightweight awaitable, as demonstrated here, return a function object which may be later called multiple times with another completion handler; effectively creating a curried initiation, be supplied with a completion handler up front in order to create a deferred sequence of chained asynchronous operations; allowing simple composed operations to be built quickly and easily. // connect the underlying socket of the websocket stream to the first // reachable resolved endpoint co_await asio::async_connect( result-&gt;sock(), co_await resolver.async_resolve( decoded.hostname, decoded.service, deferred), deferred); In the case that the endpoint we are connecting to is secure, we must do the SSL/TLS handshake: // if the connection is TLS, we will want to update the hostname if (auto *tls = result-&gt;query_ssl(); tls) { if (!SSL_set_tlsext_host_name(tls-&gt;native_handle(), decoded.hostname.c_str())) throw system_error( error_code { static_cast&lt; int &gt;(::ERR_get_error()), asio::error::get_ssl_category() }); co_await tls-&gt;async_handshake(ssl::stream_base::client, deferred); } // some variables to receive the result of the handshake attempt auto ec = error_code(); auto response = beast::websocket::response_type(); The function try_handshake simply initiates the form of websocket handshake operation which preserves the http response returned from the server. We will need this in case the websocket connection response is actually a redirect. // attempt a websocket handshake, preserving the response fmt::print(&quot;...handshake\\n&quot;); co_await result-&gt;try_handshake( ec, response, decoded.hostname, decoded.path_etc); // in case of error, we have three scenarios, detailed below: if (ec) { fmt::print(&quot;...error: {}\\n{}&quot;, ec.message(), stitch(response.base())); auto http_result = response.result_int(); switch (response.result()) { And here is the code that handles the actual redirect. Note that in this simplistic implementation, I am replacing the URL with the Location field in the web server’s response. In reality, the returned URL could be a relative URL which would need to be merged into the original URL. Boost.URL handles this nicely. Once that library is available I’ll upgrade this example. case beast::http::status::permanent_redirect: case beast::http::status::temporary_redirect: case beast::http::status::multiple_choices: case beast::http::status::found: case beast::http::status::see_other: case beast::http::status::moved_permanently: // // Scenario 1: We have been redirected // if (response.count(beast::http::field::location)) { if (++redirects &lt;= redirect_limit) { // perform the redirect by updating the URL and jumping to // the goto label above. auto &amp;loc = response[beast::http::field::location]; urlstr.assign(loc.begin(), loc.end()); goto again; } else { throw std::runtime_error(&quot;too many redirects&quot;); } } else { // // Scenario 2: we have some other HTTP response which is not an // upgrade // throw system_error(ec, stitch(&quot;malformed redirect\\r\\n&quot;, response)); } break; default: // // Scenario 3: Some other transport error // throw system_error(ec, stitch(response)); } } else { // // successful handshake // fmt::print(&quot;...success\\n{}&quot;, stitch(response.base())); } co_return result; } So with that written, all we need to do is write a simple coroutine to connect, chat and disconnect in order to test: asio::awaitable&lt; void &gt; comain(ssl::context &amp;sslctx, std::string initial_url) { auto connection = co_await connect_websock(sslctx, initial_url, 6); co_await echo(*connection, &quot;Hello, &quot;); co_await echo(*connection, &quot;World!\\n&quot;); co_await connection-&gt;close(beast::websocket::close_reason( beast::websocket::close_code::going_away, &quot;thanks for the chat!&quot;)); co_return; } A Simple Http/WebSocket Server In order to test this code, I put together a super-simple web server, which is included in the repo and run as part of the demo program. This web server runs two coroutines, each with its own acceptor. One is the acceptor for HTTP/WS connections and the other is for HTTPS/WSS connections. Of course I could have used beast’s flex helper to auto-deduce WS/WSS on the same port, but I wanted to keep the implementation as simple as possible. The HTTP server is very simple. All it does is redirect the caller to the same Target on the WSS server: asio::awaitable&lt; void &gt; serve_http(tcp::socket sock, std::string https_endpoint) { using asio::experimental::deferred; auto rxbuf = beast::flat_buffer(); auto parser = beast::http::request_parser&lt; beast::http::empty_body &gt;(); co_await beast::http::async_read(sock, rxbuf, parser, deferred); static const auto re = std::regex(&quot;(/websocket-\\\\d+)(/.*)?&quot;, std::regex_constants::icase | std::regex_constants::optimize); auto match = std::cmatch(); auto &amp;request = parser.get(); if (std::regex_match( request.target().begin(), request.target().end(), match, re)) { co_await send_redirect( sock, fmt::format(&quot;{}{}&quot;, https_endpoint, match[0].str())); } else { co_await send_error( sock, beast::http::status::not_found, fmt::format(&quot;resource {} is not recognised\\r\\n&quot;, std::string_view(request.target().data(), request.target().size()))); } } The WSS server is minutely more complex. It looks for a URL of the form /websocket-(\\d+)(/.*)? where group 1 is the “index number” of the request. If the index number is 0, the websocket request is accepted and we head off into a chat coroutine for the remainder of the connection. If it is non-zero, then the index is decremented, the URL is reconstructed with the new index, and the redirect response is sent back. So if for example you requested http://some-server/websocket-2/bar, you would be redirected along the following path: https://some-server/websocket-2/bar (first http to https transition) https://some-server/websocket-1/bar https://some-server/websocket-0/bar (websocket handshake accepted on this URL) Here’s the code: asio::awaitable&lt; void &gt; serve_https(ssl::stream&lt; tcp::socket &gt; stream, std::string https_fqdn) { try { using asio::experimental::deferred; co_await stream.async_handshake(ssl::stream_base::server, deferred); auto rxbuf = beast::flat_buffer(); auto request = beast::http::request&lt; beast::http::string_body &gt;(); co_await beast::http::async_read(stream, rxbuf, request, deferred); auto &amp;sock = stream.next_layer(); if (beast::websocket::is_upgrade(request)) { static const auto re = std::regex( &quot;/websocket-(\\\\d+)(/.*)?&quot;, std::regex_constants::icase | std::regex_constants::optimize); auto match = std::cmatch(); if (std::regex_match(request.target().begin(), request.target().end(), match, re)) { auto index = ::atoi(match[1].str().c_str()); if (index == 0) { auto wss = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;( std::move(stream)); co_await wss.async_accept(request, deferred); co_await run_echo_server(wss, rxbuf); // serve the websocket } else { // redirect to the next index down auto loc = fmt::format(&quot;{}/websocket-{}{}&quot;, https_fqdn, index - 1, match[2].str()); co_await send_redirect(stream, loc); } } else { co_await send_error(stream, beast::http::status::not_found, &quot;try /websocket-5\\r\\n&quot;); } } else { co_await send_error( stream, beast::http::status::not_acceptable, &quot;This server only accepts websocket requests\\r\\n&quot;); } } catch (system_error &amp;e) { fmt::print(&quot;serve_https: {}\\n&quot;, e.code().message()); } catch (std::exception &amp;e) { fmt::print(&quot;serve_https: {}\\n&quot;, e.what()); } The run_echo_server coroutine is about as simple as it gets. Note the use of deferred as a completion token in order to create the lightweight awaitable type. asio::awaitable&lt; void &gt; run_echo_server(beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt; &amp;wss, beast::flat_buffer &amp;rxbuf) { using asio::experimental::deferred; for (;;) { auto size = co_await wss.async_read(rxbuf, deferred); auto data = rxbuf.cdata(); co_await wss.async_write(data, deferred); rxbuf.consume(size); } } An Example of Cancellation The server is trivial, but there is one little feature I wanted to demonstrate. The purpose of the demo is: spin up a web server connect to the web server a few times and have a chat with it exit the program This then leaves the issue of causing the web server to shut down so as to release its ownership of the underlying io_context run operation. i.e. if the io_context doesn’t run out of work, the call to io_context::run() won’t return. I have taken advantage of the fact that when coroutines are spawned with an associated cancellation slot, the cancellation slot tree propagates down through all child coroutines and asio operations. So it becomes as simple as: Define a cancellation signal: auto stop_sig = asio::cancellation_signal(); Run the server, passing in the cancellation signal’s slot: svr.run(stop_sig.slot()); When the client code has completed, it simply needs to cause the signal to emit: co_spawn(ioc, comain(ioctx, initial_url), [&amp;](std::exception_ptr ep) { We emit the signal regardless of whether the client ended in an error or not - we want to stop the server in either case stop_sig.emit(asio::cancellation_type::all); try { if (ep) std::rethrow_exception(ep); } catch (std::exception &amp;e) { fmt::print(&quot;client exception: {}\\n&quot;, e.what()); } }); Within the server, we spawn the internal coroutines bound to the cancellation slot. This will cause the slot to propagate the signal into the subordinate coroutines, causing whatever they are doing to complete with an operation_aborted error. void server::run(asio::cancellation_slot stop_slot) { awaitable_operators makes dealing with parallel coroutines extremely simple. using namespace asio::experimental::awaitable_operators; using asio::bind_cancellation_slot; using asio::co_spawn; using asio::use_awaitable; fmt::print(&quot;server starting\\n&quot;); auto handler = [](std::exception_ptr ep) { try { if (ep) std::rethrow_exception(ep); } catch (asio::multiple_exceptions &amp;es) { print_exceptions(es.first_exception()); } catch (std::exception &amp;e) { print_exceptions(e); } }; Here we are creating an outer coroutine which represents the simultaneous execution of the two inner coroutines, http_server and wss_server. The completion token of this outer coroutine is bound to the supplied cancellation slot. When this slot is invoked, it will propagate the signal into the two subordinate coroutines. co_spawn(get_executor(), http_server(tcp_acceptor_, tls_root_) &amp;&amp; wss_server(sslctx_, tls_acceptor_, tls_root_), bind_cancellation_slot(stop_slot, handler)); } Final output Here is an example of the output generated by this program, tracking the various redirects and correct shutdown of all IO operations. $ ~/github/madmongo1/blog-2022-Aug-websock-redirect/cmake-build-debug/blog-2022-aug-websock-redirect Initialising server starting attempting connection: ws://127.0.0.1:38503/websocket-4 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-4 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-4 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-3 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-3 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-2 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-2 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-1 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-1 ...handshake ...error: The WebSocket handshake was declined by the remote peer HTTP/1.1 301 Moved Permanently Location: wss://127.0.0.1:45141/websocket-0 Connection: close Content-Length: 54 attempting connection: wss://127.0.0.1:45141/websocket-0 ...handshake ...success HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: upgrade Sec-WebSocket-Accept: N5wCr5WUOM6LxN8I4If7oR8QW3A= Server: Boost.Beast/330 Hello, World! serve_https: The WebSocket stream was gracefully closed at both endpoints http_server: Operation canceled wss_server: Operation canceled Finished Process finished with exit code 0 Final Note I have of course cut many corners in this demonstration. The error handling is a bit ropey and I haven’t considered timeouts, connection re-use, etc. But hopefully this will be useful to anyone reading. Until next time.","@type":"BlogPosting","url":"http://cppalliance.org/richard/2022/08/10/RichardsAugustUpdate.html","headline":"Richard’s August Update","dateModified":"2022-08-10T00:00:00+00:00","datePublished":"2022-08-10T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://cppalliance.org/richard/2022/08/10/RichardsAugustUpdate.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->



<link href="/css/prism.css" rel="stylesheet">


<link href='/feed.xml' rel='alternate' type='application/atom+xml'>

<!-- Twitter Card Start -->




  
    <meta name="twitter:image" content="https://cppalliance.org/images/logo.png">
  

<!-- Twitter Card End -->

<script defer data-domain="cppalliance.org" src="https://plausible.io/js/script.js"></script>

</head>

<body id='body' class="line-numbers">

  <!-- Navigation -->
  <nav class='nav dark'>
    <a href='/'>
      <img class='logo' alt='cpp-alliance-logo' src='/images/logo.svg' />
    </a>
    <div class='hamburger' id='nav-hamburger'>
      <span class='hamburger-line'></span>
      <span class='hamburger-line'></span>
      <span class='hamburger-line'></span>
    </div>
    <div class='nav-items' id='nav-items'>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/">Home</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#mission">Mission</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#team">Team</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#news">News</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#links">Links</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#faq">FAQ</a></div>
      <div class="nav-item"><a class="nav-link nav-link-mobile" href="/#contact">Contact</a></div>
      <div class='socials'>
        <div class='connect-content'>
          <div class='row row-sm'>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://github.com/CPPAlliance">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img github' alt='github-logo' src='/images/icons/github.svg' />
                </div>
                <span class='social-icon-text'>GitHub</span>
              </a>
            </div>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://www.facebook.com/CPPAlliance/">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img facebook' alt='facebook-logo' src='/images/icons/facebook.svg' />
                </div>
                <span class='social-icon-text'>Facebook</span>
              </a>
            </div>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://x.com/cppalliance">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img twitter' alt='x-logo' src='/images/icons/twitter.svg' />
                </div>
                <span class='social-icon-text'>X</span>
              </a>
            </div>
            <div class='col-fourth col-fourth-sm social-link'>
              <a class='social-icon nav-link-mobile' href="https://www.linkedin.com/in/cppalliance/">
                <div class='social-icon-img-wrapper'>
                  <img class='social-icon-img linkedin' alt='linkedin-logo' src='/images/icons/linkedin.svg' />
                </div>
                <span class='social-icon-text'>LinkedIn</span>
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>






  <div class='post'>
  <div class='current-article'>
    

    <section class='section article'>
      

      <article>
      <div class="title-section center">
        <h2 class='text-l news-title no-border'>Richard's August Update</h2>
        
        
                
                
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                
                  
                    
                    
        

        

        
          <div class='author d-iblock'>
            <a class='link author-img-link' href="/people/richard">
              <img class='author-img' src='/images/people/richard.jpg' alt='Portrait of Richard Hodges' />
            </a>
            <span class='text-xxs author-name'>
                <a class='link' href="/people/richard">
                  Richard Hodges
                </a> &middot; Aug 10, 2022
            </span>
          </div>
        
      </div>
        <div class='text-xxs content-text generated-content'>
          <h1 id="beast-and-http-redirect">Beast and HTTP Redirect</h1>

<p>Some months ago, I was asked how to handle HTTP redirect responses in beast.
Characteristically, I took a moment to model how I would do that in my head, waved my hands and kind of explained it and 
that was that.</p>

<p>Then more recently, someone else asked how beast websockets would handle a redirect response when performing a websocket 
handshake. Now I’m pretty sure that websocket clients have no requirement at all to follow redirects. I believe the 
WebSocket specification does not allow for such things, but I thought it would be an interesting exercise to cover the 
topic and provide a working code example and cover it in a blog post.</p>

<p>There are a few reasons I decided to do this:</p>
<ul>
  <li>Redirects are going to be important for any client-side framework written on Beast.</li>
  <li>There are a few new features in Asio which I thought it would be interesting to showcase.</li>
</ul>

<h2 id="code-repositiory">Code Repositiory</h2>

<p>The code for this blog can be found <a href="https://github.com/madmongo1/blog-2022-Aug-websock-redirect">here</a>.
I have tested it on Fedora 36 and GCC-12. The code requires at least boost-1.80.0.beta1, because it takes advantage of 
the new change in Asio, which allows the deferred object returned by the <code>asio::deferred</code> completion token to be 
directly <code>co_await</code>ed. This provides a significant improvement in performance for operations that don’t need the full
functionality of the <code>asio::awaitable&lt;&gt;</code> type.</p>

<h2 id="handling-a-redirect---general-case">Handling a Redirect - General Case</h2>

<p>Redirects can be followed with the following generalised algorithm:</p>

<pre><code>
set redirect count to 0

while not connected, no egregious errors and redirect limit has not been exceeded:

  crack URL
  resolve the FQDN of the host specified in the URL
  connect to the host
  
  if URL indicates HTTPS:
    negotiate TLS
  endif
  
  send http request (upgrade request for websocket)
  
  await response
  
  if response is 200ish:
    exit success
  elseif response is redirect:
    increment redirect count
    update URL with data found in Location header field
    continue
  else
    exit error
  endif
  
endwhile 

</code></pre>

<h2 id="handling-a-redirect-in-c-with-beast">Handling a Redirect in C++ with Beast</h2>

<p>It turns out that the entire process can be handled in one coroutine. 
Now remember that an HTTP connection can redirect to an HTTPS connection. So the “connection” type returned from a 
coroutine that creates a connection, having taken into account any redirects, must handle both transport types.</p>

<p>It’s worth mentioning at this point that if you’re writing for a modern Linux kernel, TLS is now supported natively
by the berkley sockets interface. This means that programs need no longer generate one code path for SSL and one for
TCP. If this is interesting to you, there is some documentation <a href="https://www.kernel.org/doc/html/v5.12/networking/tls.html">here</a>.
When I get a moment I will create a modified copy of this program that uses Kernel TLS. However, for now, we do it the
old-fashioned portable way.</p>

<h3 id="a-connection-abstraction">A connection abstraction</h3>

<p>First we define some useful types for our variant implementation</p>
<pre><code class="language-cpp">struct websock_connection
{
    using ws_stream  = beast::websocket::stream&lt; tcp::socket &gt;;
    using wss_stream = beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;;
    using var_type   = boost::variant2::variant&lt; ws_stream, wss_stream &gt;;
</code></pre>
<p>…provide TLS and SSL constructors…</p>

<pre><code class="language-cpp">    websock_connection(tcp::socket sock)
    : var_(ws_stream(std::move(sock)))
    {
    }

    websock_connection(ssl::stream&lt; tcp::socket &gt; stream)
    : var_(wss_stream(std::move(stream)))
    {
    }
</code></pre>

<p>…provide access to the underlying (optional) SSL and TCP streams…</p>

<pre><code class="language-cpp">    tcp::socket &amp;
    sock();

    ssl::stream&lt; tcp::socket &gt; *
    query_ssl();

</code></pre>

<p>… provide functions that return awaitables for the high level functions we will need…</p>

<pre><code class="language-cpp">    asio::awaitable&lt; void &gt;
    try_handshake(error_code                      &amp;ec,
                  beast::websocket::response_type &amp;response,
                  std::string                      hostname,
                  std::string                      target);

    asio::awaitable&lt; std::size_t &gt;
    send_text(std::string const &amp;msg);

    asio::awaitable&lt; std::string &gt;
    receive_text();

    asio::awaitable&lt; void &gt;
    close(beast::websocket::close_reason const &amp;reason);
    
</code></pre>
<p>…and finally the implementation details…</p>
<pre><code class="language-cpp">    var_type           var_;
    beast::flat_buffer rxbuffer_;
};
</code></pre>
<p>The implementation of the various member functions are then all defined in terms of <code>visit</code>, e.g.:</p>

<pre><code class="language-cpp">asio::awaitable&lt; std::size_t &gt;
websock_connection::send_text(std::string const &amp;msg)
{
    using asio::use_awaitable;

    return visit(
        [&amp;](auto &amp;ws)
        {
            ws.text();
            return ws.async_write(asio::buffer(msg), use_awaitable);
        },
        var_);
}
</code></pre>
<p>Note that this function is not actually a coroutine. Since it doesn’t maintain any state during the async operation, 
the function can simply return the <code>awaitable</code> to the calling coroutine. This saves the creation of a coroutine frame
when we don’t need it.</p>

<p>The interface and implementation for this class can be found in <code>websocket_connection.[ch]pp</code> in the git repo linked 
above.</p>

<h3 id="moveable-sslstream">Moveable <code>ssl::stream</code>?</h3>

<p>You may have noticed something in this constructor:</p>
<pre><code class="language-cpp">    websock_connection(ssl::stream&lt; tcp::socket &gt; stream)
    : var_(wss_stream(std::move(stream)))
    {
    }
</code></pre>
<p>I have <code>std::move</code>‘d the ssl stream into the WebSocket stream. Until a few versions ago, asio ssl streams were not 
moveable, which caused all kinds of issues when wanting to, for example, upgrade an SSL stream connection to a secure 
websocket stream.</p>

<p>The Beast library has two workarounds for this:</p>
<ol>
  <li>Beast provides its own version of ssl::stream, and</li>
  <li><code>beast::websocket::stream</code> has a specialisation defined which holds a reference to a stream.</li>
</ol>

<p>These are probably now un-necessary and could arguably be deprecated.</p>

<h2 id="the-algorithm-in-c20">The algorithm in C++20</h2>

<pre><code class="language-cpp">asio::awaitable&lt; std::unique_ptr&lt; websock_connection &gt; &gt;
connect_websock(ssl::context &amp;sslctx,
                std::string   urlstr,
                int const     redirect_limit = 5)
{
    using asio::experimental::deferred;

    // for convenience, take a copy of the current executor
    auto ex = co_await asio::this_coro::executor;

    // number of redirects detected so far
    int redirects = 0;

    // build a resolver in order tp decode te FQDNs in urls
    auto resolver = tcp::resolver(ex);

    // in the case of a redirect, we will resume processing here
again:
    fmt::print("attempting connection: {}\n", urlstr);

    // decode the URL into components
    auto decoded = decode_url(urlstr);
</code></pre>
<p>This part of the code builds a unique pointer to an initialised <code>websocket_connection</code> object, initialised with either 
an SSL stream or a TCP stream as indicated by the result of cracking the URL. For brevity I have used a regex to crack 
the URL, but you should check out Vinnie Falco’s new Boost.URL candidate library <a href="https://github.com/CPPAlliance/url">here</a>.
Vinnie will be looking for reviewers during this library’s submission to Boost later this month, so do keep an eye out
in the Boost mailing list.</p>

<pre><code class="language-cpp">    // build the appropriate websocket stream type depending on whether the URL
    // indicates a TCP or TLS transport
    auto result = decoded.transport == transport_type::tls
                      ? std::make_unique&lt; websock_connection &gt;(
                            ssl::stream&lt; tcp::socket &gt;(ex, sslctx))
                      : std::make_unique&lt; websock_connection &gt;(tcp::socket(ex));

</code></pre>

<p>Here we are awaiting a connect operation with the result of awaiting a resolve operation. Note the use of 
<code>asio::experimental::deferred</code>. <code>deferred</code> is quite a versatile completion token which can be used to:</p>
<ul>
  <li>return an lightweight awaitable, as demonstrated here,</li>
  <li>return a function object which may be later called multiple times with another completion handler; 
effectively creating a curried initiation,</li>
  <li>be supplied with a completion handler up front in order to create a deferred sequence of chained asynchronous 
operations; allowing simple composed operations to be built quickly and easily.</li>
</ul>

<pre><code class="language-cpp">    // connect the underlying socket of the websocket stream to the first
    // reachable resolved endpoint
    co_await asio::async_connect(
        result-&gt;sock(),
        co_await resolver.async_resolve(
            decoded.hostname, decoded.service, deferred),
        deferred);
</code></pre>

<p>In the case that the endpoint we are connecting to is secure, we must do the SSL/TLS handshake:</p>

<pre><code class="language-cpp">    // if the connection is TLS, we will want to update the hostname
    if (auto *tls = result-&gt;query_ssl(); tls)
    {
        if (!SSL_set_tlsext_host_name(tls-&gt;native_handle(),
                                      decoded.hostname.c_str()))
            throw system_error(
                error_code { static_cast&lt; int &gt;(::ERR_get_error()),
                             asio::error::get_ssl_category() });
        co_await tls-&gt;async_handshake(ssl::stream_base::client, deferred);
    }

    // some variables to receive the result of the handshake attempt
    auto ec       = error_code();
    auto response = beast::websocket::response_type();
</code></pre>
<p>The function try_handshake simply initiates the form of websocket handshake operation which preserves the 
http response returned from the server. We will need this in case the websocket connection response is actually a
redirect.</p>

<pre><code class="language-cpp">    // attempt a websocket handshake, preserving the response
    fmt::print("...handshake\n");
    co_await result-&gt;try_handshake(
        ec, response, decoded.hostname, decoded.path_etc);

    // in case of error, we have three scenarios, detailed below:
    if (ec)
    {
        fmt::print("...error: {}\n{}", ec.message(), stitch(response.base()));
        auto http_result = response.result_int();
        switch (response.result())
        {
</code></pre>

<p>And here is the code that handles the actual redirect. Note that in this simplistic implementation, I am replacing the
URL with the <code>Location</code> field in the web server’s response. In reality, the returned URL could be a relative URL which 
would need to be merged into the original URL. <a href="https://github.com/CPPAlliance/url">Boost.URL</a> handles this nicely. 
Once that library is available I’ll upgrade this example.</p>

<pre><code class="language-cpp">        case beast::http::status::permanent_redirect:
        case beast::http::status::temporary_redirect:
        case beast::http::status::multiple_choices:
        case beast::http::status::found:
        case beast::http::status::see_other:
        case beast::http::status::moved_permanently:
            //
            // Scenario 1: We have been redirected
            //
            if (response.count(beast::http::field::location))
            {
                if (++redirects &lt;= redirect_limit)
                {
                    // perform the redirect by updating the URL and jumping to
                    // the goto label above.
                    auto &amp;loc = response[beast::http::field::location];
                    urlstr.assign(loc.begin(), loc.end());
                    goto again;
                }
                else
                {
                    throw std::runtime_error("too many redirects");
                }
            }
            else
            {
                //
                // Scenario 2: we have some other HTTP response which is not an
                // upgrade
                //
                throw system_error(ec,
                                   stitch("malformed redirect\r\n", response));
            }
            break;

        default:
            //
            // Scenario 3: Some other transport error
            //
            throw system_error(ec, stitch(response));
        }
    }
    else
    {
        //
        // successful handshake
        //
        fmt::print("...success\n{}", stitch(response.base()));
    }

    co_return result;
}
</code></pre>

<p>So with that written, all we need to do is write a simple coroutine to connect, chat and disconnect in order to test:</p>

<pre><code class="language-cpp">asio::awaitable&lt; void &gt;
comain(ssl::context &amp;sslctx, std::string initial_url)
{
    auto connection = co_await connect_websock(sslctx, initial_url, 6);
    co_await echo(*connection, "Hello, ");
    co_await echo(*connection, "World!\n");
    co_await connection-&gt;close(beast::websocket::close_reason(
        beast::websocket::close_code::going_away, "thanks for the chat!"));
    co_return;
}
</code></pre>

<h2 id="a-simple-httpwebsocket-server">A Simple Http/WebSocket Server</h2>

<p>In order to test this code, I put together a super-simple web server, which is included in the repo and run as part of
the demo program.</p>

<p>This web server runs two coroutines, each with its own acceptor. One is the acceptor for HTTP/WS connections and the other
is for HTTPS/WSS connections. Of course I could have used beast’s 
<a href="https://www.boost.org/doc/libs/1_79_0/libs/beast/doc/html/beast/ref/boost__beast__async_detect_ssl.html">flex helper</a> 
to auto-deduce WS/WSS on the same port, but I wanted to keep the implementation as simple as possible.</p>

<p>The HTTP server is very simple. All it does is redirect the caller to the same <code>Target</code> on the WSS server:</p>

<pre><code class="language-cpp">asio::awaitable&lt; void &gt;
serve_http(tcp::socket sock, std::string https_endpoint)
{
    using asio::experimental::deferred;

    auto rxbuf  = beast::flat_buffer();
    auto parser = beast::http::request_parser&lt; beast::http::empty_body &gt;();
    co_await beast::http::async_read(sock, rxbuf, parser, deferred);

    static const auto re      = std::regex("(/websocket-\\d+)(/.*)?",
                                      std::regex_constants::icase |
                                          std::regex_constants::optimize);
    auto              match   = std::cmatch();
    auto             &amp;request = parser.get();
    if (std::regex_match(
            request.target().begin(), request.target().end(), match, re))
    {
        co_await send_redirect(
            sock, fmt::format("{}{}", https_endpoint, match[0].str()));
    }
    else
    {
        co_await send_error(
            sock,
            beast::http::status::not_found,
            fmt::format("resource {} is not recognised\r\n",
                        std::string_view(request.target().data(),
                                         request.target().size())));
    }
}
</code></pre>

<p>The WSS server is minutely more complex. It looks for a URL of the form <code>/websocket-(\d+)(/.*)?</code> where group 1 is the 
“index number” of the request. If the index number is 0, the websocket request is accepted and we head off into a chat
coroutine for the remainder of the connection. If it is non-zero, then the index is decremented, the URL is 
reconstructed with the new index, and the redirect response is sent back.</p>

<p>So if for example you requested <code>http://some-server/websocket-2/bar</code>, you would be redirected along the following path:</p>
<ul>
  <li><code>https://some-server/websocket-2/bar</code> (first http to https transition)</li>
  <li><code>https://some-server/websocket-1/bar</code></li>
  <li><code>https://some-server/websocket-0/bar</code> (websocket handshake accepted on this URL)</li>
</ul>

<p>Here’s the code:</p>

<pre><code class="language-cpp">asio::awaitable&lt; void &gt;
serve_https(ssl::stream&lt; tcp::socket &gt; stream, std::string https_fqdn)
{
    try
    {
        using asio::experimental::deferred;

        co_await stream.async_handshake(ssl::stream_base::server, deferred);

        auto rxbuf   = beast::flat_buffer();
        auto request = beast::http::request&lt; beast::http::string_body &gt;();
        co_await beast::http::async_read(stream, rxbuf, request, deferred);

        auto &amp;sock = stream.next_layer();
        if (beast::websocket::is_upgrade(request))
        {
            static const auto re = std::regex(
                "/websocket-(\\d+)(/.*)?",
                std::regex_constants::icase | std::regex_constants::optimize);
            auto match = std::cmatch();
            if (std::regex_match(request.target().begin(),
                                 request.target().end(),
                                 match,
                                 re))
            {
                auto index = ::atoi(match[1].str().c_str());
                if (index == 0)
                {
                    auto wss =
                        beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt;(
                            std::move(stream));
                    co_await wss.async_accept(request, deferred);
                    co_await run_echo_server(wss, rxbuf);
                    // serve the websocket
                }
                else
                {
                    // redirect to the next index down
                    auto loc = fmt::format("{}/websocket-{}{}",
                                           https_fqdn,
                                           index - 1,
                                           match[2].str());
                    co_await send_redirect(stream, loc);
                }
            }
            else
            {
                co_await send_error(stream,
                                    beast::http::status::not_found,
                                    "try /websocket-5\r\n");
            }
        }
        else
        {
            co_await send_error(
                stream,
                beast::http::status::not_acceptable,
                "This server only accepts websocket requests\r\n");
        }
    }
    catch (system_error &amp;e)
    {
        fmt::print("serve_https: {}\n", e.code().message());
    }
    catch (std::exception &amp;e)
    {
        fmt::print("serve_https: {}\n", e.what());
    }
</code></pre>

<p>The <code>run_echo_server</code> coroutine is about as simple as it gets. Note the use of <code>deferred</code> as a completion token in order
to create the lightweight awaitable type.</p>

<pre><code class="language-cpp">asio::awaitable&lt; void &gt;
run_echo_server(beast::websocket::stream&lt; ssl::stream&lt; tcp::socket &gt; &gt; &amp;wss,
                beast::flat_buffer                                     &amp;rxbuf)
{
    using asio::experimental::deferred;

    for (;;)
    {
        auto size = co_await wss.async_read(rxbuf, deferred);
        auto data = rxbuf.cdata();
        co_await wss.async_write(data, deferred);
        rxbuf.consume(size);
    }
}
</code></pre>

<h2 id="an-example-of-cancellation">An Example of Cancellation</h2>

<p>The server is trivial, but there is one little feature I wanted to demonstrate.</p>

<p>The purpose of the demo is:</p>
<ul>
  <li>spin up a web server</li>
  <li>connect to the web server a few times and have a chat with it</li>
  <li>exit the program</li>
</ul>

<p>This then leaves the issue of causing the web server to shut down so as to release its ownership of the underlying 
io_context run operation. i.e. if the io_context doesn’t run out of work, the call to <code>io_context::run()</code> won’t return.</p>

<p>I have taken advantage of the fact that when coroutines are spawned with an associated cancellation slot, the 
cancellation slot tree propagates down through all child coroutines and asio operations.</p>

<p>So it becomes as simple as:</p>

<p>Define a cancellation signal:</p>

<pre><code class="language-cpp">    auto stop_sig = asio::cancellation_signal();
</code></pre>

<p>Run the server, passing in the cancellation signal’s slot:</p>
<pre><code class="language-cpp">    svr.run(stop_sig.slot());
</code></pre>

<p>When the client code has completed, it simply needs to cause the signal to emit:</p>

<pre><code class="language-cpp">    co_spawn(ioc,
             comain(ioctx, initial_url),
             [&amp;](std::exception_ptr ep)
             {
</code></pre>
<p>We emit the signal regardless of whether the client ended in an error or not - we want to stop the server in either case</p>
<pre><code class="language-cpp">                 stop_sig.emit(asio::cancellation_type::all);
                 try
                 {
                     if (ep)
                         std::rethrow_exception(ep);
                 }
                 catch (std::exception &amp;e)
                 {
                     fmt::print("client exception: {}\n", e.what());
                 }
             });

</code></pre>

<p>Within the server, we spawn the internal coroutines bound to the cancellation slot. This will cause the slot to
propagate the signal into the subordinate coroutines, causing whatever they are doing to complete with an 
<code>operation_aborted</code> error.</p>

<pre><code class="language-cpp">void
server::run(asio::cancellation_slot stop_slot)
{
</code></pre>
<p><code>awaitable_operators</code> makes dealing with parallel coroutines extremely simple.</p>
<pre><code class="language-cpp">    using namespace asio::experimental::awaitable_operators;
    using asio::bind_cancellation_slot;
    using asio::co_spawn;
    using asio::use_awaitable;

    fmt::print("server starting\n");

    auto handler = [](std::exception_ptr ep)
    {
        try
        {
            if (ep)
                std::rethrow_exception(ep);
        }
        catch (asio::multiple_exceptions &amp;es)
        {
            print_exceptions(es.first_exception());
        }
        catch (std::exception &amp;e)
        {
            print_exceptions(e);
        }
    };
</code></pre>

<p>Here we are creating an outer coroutine which represents the simultaneous execution of the two inner coroutines, 
<code>http_server</code> and <code>wss_server</code>. The completion token of this outer coroutine is bound to the supplied cancellation slot.
When this slot is invoked, it will propagate the signal into the two subordinate coroutines.</p>

<pre><code class="language-cpp">    co_spawn(get_executor(),
             http_server(tcp_acceptor_, tls_root_) &amp;&amp;
                 wss_server(sslctx_, tls_acceptor_, tls_root_),
             bind_cancellation_slot(stop_slot, handler));
}
</code></pre>

<h2 id="final-output">Final output</h2>

<p>Here is an example of the output generated by this program, tracking the various redirects and correct shutdown of all 
IO operations.</p>

<pre><code class="language-text">$ ~/github/madmongo1/blog-2022-Aug-websock-redirect/cmake-build-debug/blog-2022-aug-websock-redirect
Initialising
server starting
attempting connection: ws://127.0.0.1:38503/websocket-4
...handshake
...error: The WebSocket handshake was declined by the remote peer
HTTP/1.1 301 Moved Permanently
Location: wss://127.0.0.1:45141/websocket-4
Connection: close
Content-Length: 54

attempting connection: wss://127.0.0.1:45141/websocket-4
...handshake
...error: The WebSocket handshake was declined by the remote peer
HTTP/1.1 301 Moved Permanently
Location: wss://127.0.0.1:45141/websocket-3
Connection: close
Content-Length: 54

attempting connection: wss://127.0.0.1:45141/websocket-3
...handshake
...error: The WebSocket handshake was declined by the remote peer
HTTP/1.1 301 Moved Permanently
Location: wss://127.0.0.1:45141/websocket-2
Connection: close
Content-Length: 54

attempting connection: wss://127.0.0.1:45141/websocket-2
...handshake
...error: The WebSocket handshake was declined by the remote peer
HTTP/1.1 301 Moved Permanently
Location: wss://127.0.0.1:45141/websocket-1
Connection: close
Content-Length: 54

attempting connection: wss://127.0.0.1:45141/websocket-1
...handshake
...error: The WebSocket handshake was declined by the remote peer
HTTP/1.1 301 Moved Permanently
Location: wss://127.0.0.1:45141/websocket-0
Connection: close
Content-Length: 54

attempting connection: wss://127.0.0.1:45141/websocket-0
...handshake
...success
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: upgrade
Sec-WebSocket-Accept: N5wCr5WUOM6LxN8I4If7oR8QW3A=
Server: Boost.Beast/330

Hello, World!
serve_https: The WebSocket stream was gracefully closed at both endpoints
http_server: Operation canceled
wss_server: Operation canceled
Finished

Process finished with exit code 0
</code></pre>

<h1 id="final-note">Final Note</h1>

<p>I have of course cut many corners in this demonstration. The error handling is a bit ropey and I haven’t considered 
timeouts, connection re-use, etc.</p>

<p>But hopefully this will be useful to anyone reading.</p>

<p>Until next time.</p>

        </div>
      </article>
    </section>
  </div>

  <section class="section news bottom-layout" id='news'>
    <div class='section-title'>
      <h2 class='header text-xl recent-post-header'>All Posts by This Author</h2>
    </div>
    <div class='news-content formatted-text'>
      <ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>08/10/2022</span>
          <a class='text-l news-title link' href="/richard/2022/08/10/RichardsAugustUpdate.html">Richard's August Update</a>
        </li>
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>10/10/2021</span>
          <a class='text-l news-title link' href="/richard/2021/10/10/RichardsOctoberUpdate.html">Richard's October Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>05/30/2021</span>
          <a class='text-l news-title link' href="/richard/2021/05/30/RichardsMayUpdate.html">Richard's May 2021 Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>04/30/2021</span>
          <a class='text-l news-title link' href="/richard/2021/04/30/RichardsAprilUpdate.html">Richard's April Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>03/30/2021</span>
          <a class='text-l news-title link' href="/richard/2021/03/30/RichardsMarchUpdate.html">Richard's February/March Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>01/31/2021</span>
          <a class='text-l news-title link' href="/richard/2021/01/31/RichardsJanuaryUpdate.html">Richard's January Update</a>
        </li>
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>01/01/2021</span>
          <a class='text-l news-title link' href="/richard/2021/01/01/RichardsNewYearUpdate.html">Richard's New Year Update - Reusable HTTP Connections</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>12/22/2020</span>
          <a class='text-l news-title link' href="/richard/2020/12/22/RichardsDecemberUpdate.html">Richard's November/December Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>10/31/2020</span>
          <a class='text-l news-title link' href="/richard/2020/10/31/RichardsOctoberUpdate.html">Richard's October Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>09/30/2020</span>
          <a class='text-l news-title link' href="/richard/2020/09/30/RichardsSeptemberUpdate.html">Richard's September Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>09/01/2020</span>
          <a class='text-l news-title link' href="/richard/2020/09/01/RichardsAugustUpdate.html">Richard's August Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>08/01/2020</span>
          <a class='text-l news-title link' href="/richard/2020/08/01/RichardsJulyUpdate.html">Richard's July Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>07/01/2020</span>
          <a class='text-l news-title link' href="/richard/2020/07/01/RichardsJuneUpdate.html">Richard's May/June Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>04/30/2020</span>
          <a class='text-l news-title link' href="/richard/2020/04/30/RichardsAprilUpdate.html">Richard's April Update</a>
        </li>
        
        
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>03/31/2020</span>
          <a class='text-l news-title link' href="/richard/2020/03/31/RichardsMarchUpdate.html">Richard's March Update</a>
        </li>
        
        
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>02/29/2020</span>
          <a class='text-l news-title link' href="/richard/2020/02/29/RichardsFebruaryUpdate.html">Richard's February Update</a>
        </li>
        
        
        
        <li class='news-list-item '>
          <span class='text-xs news-date'>01/31/2020</span>
          <a class='text-l news-title link' href="/richard/2020/01/31/RichardsJanuaryUpdate.html">Richard's January Update</a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        <li>
          <a class='text-l all link' href="/news">View All Posts...</a>
        </li>
      </ul>
    </div>
  </section>

</div>


  <footer class='footer'>
    <p class='text-xxs footer-text'>
      <span class='line'>&copy; 2024 The C Plus Plus Alliance, Inc.</span>
      <span class='line'>Contact us at: <a href='mailto:%69%6E%66%6F@%63%70%70%61%6C%6C%69%61%6E%63%65.%6F%72%67'>info@cppalliance.org</a></span>
    </p>
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src='/js/main.js'></script>
  
  <script src='/js/prism.js'></script>
  

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-76438364-18', 'auto');
    ga('send', 'pageview');
  </script>

</body>
</html>
